Navigation: [[Binary Exploitation]]

---
# Tools

# Useful Commands
Initial stuff:
```bash
# Check file type
file <file>

# Check security configuration:
checksec --file=<file>

# Disass and dump
objdump -M intel -d <file>

# Dump function addresses
nm -a <file>

# Check system/library calls respectively
strace <file>
ltrace <file>

# Check library imports
ldd <file>

# Enable/Disable ASLR
echo 1 > sudo tee /proc/sys/kernel/randomize_va_space
echo 0 > sudo tee /proc/sys/kernel/randomize_va_space
```

Buffer overflow commands:
```bash
# All of these are pwntools commands
pwndbg <file>
cyclic 512 # generate a cyclic pattern of len 512
cyclic -l <pattern> # find the length of the input (use first 4 bytes of rsp val)
piebase # Check PIE base address
breakrva 0x0000 # break at offset, regardless of base address
```

# Boilerplate Scripts
```python
from pwn import *

# Allows you to switch between local/GDB/remote from terminal
def start(argv=[], *a, **kw):
    if args.GDB:  # Set GDBscript below
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:  # ('server', 'port')
        return remote(sys.argv[1], sys.argv[2], *a, **kw)
    else:  # Run locally
        return process([exe] + argv, *a, **kw)

# Specify your GDB script here for debugging
gdbscript = '''
init-pwndbg
continue
'''.format(**locals())

# Set up pwntools for the correct architecture
exe = './<file>'
# This will automatically get context arch, bits, os etc
elf = context.binary = ELF(exe, checksec=False)
# Enable verbose logging so we can see exactly what is being sent (info/debug)
context.log_level = 'debug'

# ===========================================================
#                    EXPLOIT GOES HERE
# ===========================================================

```


---
Navigation: [[Binary Exploitation]]