Navigation: [[Binary Exploitation]]

---
# Introduction
A buffer overflow is a vulnerability that occurs when a program writes more data to a buffer than it can hold. This can lead to overwriting adjacent memory within the program, causing crashes or allow arbitrary code execution.

Here's an example of a vulnerable program:
```C
void vuln ()
{
  char buf[16];
  gets (buf); // gets() is considered unsafe since it doesn't check input length 
  return;
}

int main ()
{
  vuln ();
  return 0;
}
```

If we were to look at the assembly of a vulnerable program, 
```asm
section .text
    global main

vuln:
    push rbp
    mov rbp, rsp
    sub rsp, 16
    lea rdi, [rbp-16]
    call gets            ; vulnerable call
    leave
    ret

main:
    push rbp
    mov rbp, rsp
    call vuln
    mov eax, 0
    leave
    ret

```
# Table of Contents
1. List of Unsafe Functions
2. Basic Attacks
	1. Ret2Win
	2. Ret2Shellcode
3. ROP
	1. Basic ROP Chains
	2. Ret2LibC
4. Common Protections
	1. Canaries
	2. ASLR and PIE

# List of Unsafe Functions
Here's a list of functions that can be used for buffer overflows and their safer alternatives:

| **Unsafe Function** | **Use**                                   | **Why It's Unsafe**                                                        | **Safer Alternative**                            |
| ------------------- | ----------------------------------------- | -------------------------------------------------------------------------- | ------------------------------------------------ |
| `gets()`            | Reads an entire line from `stdin`.        | Does not limit the number of characters read, leading to buffer overflows. | `fgets()` with a specified size.                 |
| `scanf()`           | Reads formatted input.                    | `%s` reads strings without bounds checking.                                | Use `%ns` or `fgets()`.                          |
| `strcpy()`          | Copies a string to a destination buffer.  | No bounds checking, can overwrite adjacent memory.                         | `strncpy()` or `strlcpy()` (if available).       |
| `strcat()`          | Appends a string to another.              | No bounds checking, can cause buffer overflows.                            | `strncat()` or `strlcat()` (if available).       |
| `sprintf()`         | Writes formatted data to a buffer.        | No bounds checking, can overwrite adjacent memory.                         | `snprintf()` with a specified size.              |
| `strncpy()`         | Copies a string to a destination buffer.  | Can lead to non-null-terminated strings if size is incorrect.              | Calculate size carefully or use safer libraries. |
| `memcpy()`          | Copies memory from source to destination. | No bounds checking, leading to memory corruption.                          | Use `memmove()` with proper checks.              |
| `bcopy()`           | Copies memory from source to destination. | Similar to `memcpy()`, lacks bounds checking.                              | Use `memmove()` with proper checks.              |
| `read()`            | Reads raw data into a buffer.             | No bounds checking on the buffer size.                                     | Validate input size or use `pread()`.            |
| `getsockopt()`      | Gets socket options.                      | May overflow buffers if `optval` size is mismanaged.                       | Validate buffer size carefully.                  |
| `realpath()`        | Resolves a file path.                     | Writes resolved path into a buffer without bounds checking.                | Use with a dynamically allocated buffer.         |
# Basic Attacks
There's 2 main attacks for just classical overflows: ret2win and ret2shellcode. Our attack path for both is very similar:
1. Find buffer length
2. Overwrite return with address to jump to

In ret2win, we'll simply overwrite the return address with our win function.

In ret2shellcode, we'll be overwriting the buffer with our shellcode. We'll set our return address to the start of the buffer (which we'll have to leak out or calculate somehow). Note that this is only possible if the NX protection is disabled. 

Here's some sample C code that is vulnerable to both:
```c
void win ()
{
  printf ("You win\n");
  return;
}

void vuln ()
{
  char buf[256];
  gets (buf); // gets() is considered unsafe since it doesn't check input length 
  return;
}

int main ()
{
  vuln ();
  return 0;
}
```
# ROP
Here's the fun part. ROP consists of chaining different return addresses on the stack to make multiple calls. Our return addresses are called "gadgets", which are often small sets of two to three instructions at the end of functions.

Here's how we can find gadgets:
```
ROPGadget --binary=<file>
```

There's also the following tools:
https://scoding.de/ropper/
https://github.com/0vercl0k/rp

**Different ROP Techniques**:
1. Adding values to registers
2. Stack pivots
### Ret2LibC
Ret2LibC is a ROP exploit where we return to the `libc` executable on the system. The basic attack often goes as follows:
1. Find `libc` address (often by leaking it due to ASLR and PIE)
2. Calculate offsets for the string `/bin/sh` and function `system()`
3. Call `system('/bin/sh')`

The ROP Arms Race was fueled by [this paper](https://doi.org/10.1145/1609956.160996). It spawned the following techniques:
1. B(lock)OP: ROP on a block (or multi-block) level by carefully compensating for side-effects.
2. J(ump)OP: instead of returns, use indirect jumps to control execution flow
3. C(all)OP: instead of returns, use indirect calls to control execution flow
4. S(ignreturn)ROP: instead of returns, use the sigreturn system call
5. D(ata)OP: instead of hijacking control flow, carefully overwrite the program's data to puppet it


---
Navigation: [[Binary Exploitation]]