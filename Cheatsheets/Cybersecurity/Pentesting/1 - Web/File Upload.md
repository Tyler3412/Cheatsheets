Navigation: [[Pentesting]]

---
# Table of Contents
1. Introduction
2. Client Side Validation
3. Server Side Validation
4. Limited Upload Attacks
# Introduction
File upload attacks involve uploading a file that the user shouldn't be able to. From here, they're able to run that file through accessing it on the web server, often resulting in RCE. If we don't get RCE, we can introduce vulnerabilities such as `XSS` or `XXE`, cause `DoS`, or overwrite system configuration files.

This vulnerability is caused by improper filtering and validation of uploaded files. It can also be caused by the use of outdated libraries. It's rated as `high` or `critical` in most vulnerability reports.

The most basic version of this vulnerability is arbitrary file upload, where there's no validation filters on uploaded files. We can either upload a web shell or reverse shell, then access that file. 

Note that when sending a web shell, we'll need to use Burp Intruder to fuzz for it using a [word list](https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/web-extensions.txt), or sometimes we might just be able to see it without fuzzing. We'll need to use the correct type of extension for our web app.
# Client Side Validation
Many web apps rely on front end JavaScript to validate files. This can easily be bypassed through just direct interaction with the server, skipping front end validation.

This essentially allows us arbitrary upload if the back end doesn't validate. When checking the request through burp, we can see that the front end validations remove anything that shouldn't be in the request. However, we can simply modify the request as it's being sent

We can also just remove or modify any client side validation we find using developer tools if we don't want to use burp.
# Server Side Validation
### Extension Filters
The first step in working against any filter is to find a list of allowed extensions. Not all extensions work with all web server configurations. `PayloadAllTheThings` has lists for [`PHP`](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Upload%20Insecure%20Files/Extension%20PHP/extensions.lst) and [`.NET`](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20Insecure%20Files/Extension%20ASP) extensions. There's also a [list](https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/web-extensions.txt) of common web extensions.

When we make a file upload request using burp, simply send the request to intruder, select sniper, then configure our request as such:
![[file_uploads_burp_fuzz_extension.jpg]]

From here, simply just load in the extensions in the payload options and uncheck the URL encoding option. We can then sort our results to see what's been successful.

There are two types of filters: blacklist and whitelist.

With blacklist filters, we'll often find specific file types be excluded. This may also include file content sometimes. The weakest type of validation is testing the file extension against a blacklist.

An example bit of PHP code that does so is the following:
```PHP
$fileName = basename($_FILES["uploadFile"]["name"]);
$extension = pathinfo($fileName, PATHINFO_EXTENSION);
$blacklist = array('php', 'php7', 'phps');

if (in_array($extension, $blacklist)) {
    echo "File type not allowed";
    die();
}
```

Note that the comparison above is case sensitive. In Windows Servers, a good thing to note is that file names are case insensitive.

Whitelist filters have a list of approved file extensions. An example would be:
```PHP
$fileName = basename($_FILES["uploadFile"]["name"]);

if (!preg_match('^.*\.(jpg|jpeg|png|gif)', $fileName)) {
    echo "Only images are allowed";
    die();
}
```

A very straightforward way to bypass the above extension is simply by using double extensions. For the above example. `*.jpg.php` would bypass this filter.

This might not always work, especially if a regex like the following is used:
```PHP
if (!preg_match('/^.*\.(jpg|jpeg|png|gif)$/', $fileName))
```

With some server configurations, we can also use a reverse double extension. The XML configuration for the following would look like:
```XML
<FilesMatch ".+\.ph(ar|p|tml)">
    SetHandler application/x-httpd-php
</FilesMatch>
```

The above extension allows anything with `.php` in the name to be run as a PHP file.

The last thing we can try against whitelist filters is character injection. For example, `shell.php%00.jpg` would work with PHP 5.X or below due to their null termination bug.

Here's a simple script we can use to generate a word list:
```shell
for char in '%20' '%0a' '%00' '%0d0a' '/' '.\\' '.' 'â€¦' ':'; do
    for ext in '.php' '.phps'; do
        echo "shell$char$ext.jpg" >> wordlist.txt
        echo "shell$ext$char.jpg" >> wordlist.txt
        echo "shell.jpg$char$ext" >> wordlist.txt
        echo "shell.jpg$ext$char" >> wordlist.txt
    done
done
```
### Type Filters
These filters are usually regarding content type headers or file content itself. 

If we think we're being limited by content type, we can use a [Content Type Wordlist](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt) to find which types are allowed. Fuzz for this the similarly to the above using burp.

The more common type of filter is file content. The content is validated by checking the file's MIME type. This is often done by checking [magic bytes](https://en.wikipedia.org/wiki/List_of_file_signatures). We can simply bypass this by appending the correct magic bytes to the file header.
# Limited Upload Attacks
Sometimes, we won't always be able to upload a web shell or reverse shell. In times like these, we can refer to the below table to see the type of attack available to us based on file type:

| Attack   | File Types                  |
| -------- | --------------------------- |
| XSS      | HTML, JS, SVG, and GIF      |
| XXE/SSRF | XML, SVG, PDF, PPT, and DOC |
| DoS      | ZIP, JPG, PNG               |

---
Navigation: [[Pentesting]]